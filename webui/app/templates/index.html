<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Measuring Device Frontend</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        .settings-group { display: none; } /* Initially hide all specific settings */
        .settings-group.active { display: block; } /* Show active settings */
    </style>
</head>
<body>
    <div class="sidebar">
        <h2>Settings</h2>
        <label for="target_board">Target Board:</label>
        <select id="target_board" name="target_board">
            <!-- Options will be populated dynamically -->
        </select>

        <label for="measure_mode">Measure Mode:</label>
        <select id="measure_mode" name="measure_mode">
            <option value="va">VA Characteristics</option>
            <option value="bode">Frequency/Phase Response (Bode)</option>
            <option value="step">Step Response</option>
            <option value="impulse">Impulse Response</option>
            <option value="testbed">Testbed</option>
            <option value="control_system">Control Systems Toolbox</option>
        </select>

        <!-- VA Characteristics Settings -->
        <div id="settings_va" class="settings-group">
            <h3>VA Settings</h3>
            <label for="va_channel">Channel:</label>
            <select id="va_channel" name="va_channel">
                <option value="CH0">CH0</option>
                <option value="CH1">CH1</option>
                <option value="CH2">CH2</option>
            </select>
            <label for="va_mode_type">Mode:</label>
            <select id="va_mode_type" name="va_mode_type">
                <option value="CV">CV (Constant Voltage)</option>
                <option value="CC">CC (Constant Current)</option>
            </select>
            <label for="va_shunt_resistance">Shunt Resistance (Ohms):</label>
            <input type="number" id="va_shunt_resistance" name="va_shunt_resistance" value="1.0" step="0.001" min="0.001">
            <div id="va_cv_settings">
                <label for="va_start_voltage">Start Voltage (V):</label>
                <input type="number" id="va_start_voltage" name="va_start_voltage" value="0" step="0.1">
                <label for="va_end_voltage">End Voltage (V):</label>
                <input type="number" id="va_end_voltage" name="va_end_voltage" value="5" step="0.1">
                <label for="va_step_voltage">Step Voltage (V):</label>
                <input type="number" id="va_step_voltage" name="va_step_voltage" value="0.1" step="0.01">
            </div>
            <div id="va_cc_settings" style="display: none;">
                <label for="va_start_current">Start Current (A):</label>
                <input type="number" id="va_start_current" name="va_start_current" value="0" step="0.01">
                <label for="va_end_current">End Current (A):</label>
                <input type="number" id="va_end_current" name="va_end_current" value="1" step="0.01">
                <label for="va_step_current">Step Current (A):</label>
                <input type="number" id="va_step_current" name="va_step_current" value="0.01" step="0.001">
            </div>
        </div>

        <!-- Bode Plot Settings -->
        <div id="settings_bode" class="settings-group">
            <h3>Bode Plot Settings</h3>
            <label for="bode_channel">Channel:</label>
            <select id="bode_channel" name="bode_channel">
                <option value="CH0">CH0</option>
                <option value="CH1">CH1</option>
                <option value="CH2">CH2</option>
            </select>
            <label for="bode_freq_from">Freq From (Hz):</label>
            <input type="number" id="bode_freq_from" name="bode_freq_from" value="10" min="1">
            <label for="bode_freq_to">Freq To (Hz):</label>
            <input type="number" id="bode_freq_to" name="bode_freq_to" value="10000" max="10000">
            <label for="bode_freq_steps">Freq Points/Decade:</label> <!-- Changed from step to points for better log scale -->
            <input type="number" id="bode_freq_steps" name="bode_freq_steps" value="10" min="1">
            <label for="bode_output_voltage">Output Voltage (V):</label>
            <input type="number" id="bode_output_voltage" name="bode_output_voltage" value="1" min="0" max="20" step="0.1">
        </div>

        <!-- Step Response Settings -->
        <div id="settings_step" class="settings-group">
            <h3>Step Response Settings</h3>
            <label for="step_channel">Channel:</label>
            <select id="step_channel" name="step_channel">
                <option value="CH0">CH0</option>
                <option value="CH1">CH1</option>
                <option value="CH2">CH2</option>
            </select>
            <label for="step_voltage">Voltage (V):</label>
            <input type="number" id="step_voltage" name="step_voltage" value="5" min="0" max="20" step="0.1">
            <label for="step_time">Measurement Time (s):</label>
            <input type="number" id="step_time" name="step_time" value="1" min="0.001" step="0.001">
        </div>

        <!-- Impulse Response Settings -->
        <div id="settings_impulse" class="settings-group">
            <h3>Impulse Response Settings</h3>
            <label for="impulse_voltage">Impulse Voltage (V):</label>
            <input type="number" id="impulse_voltage" name="impulse_voltage" value="5" min="0" max="20" step="0.1">
            <label for="impulse_duration">Impulse Duration (us):</label>
            <input type="number" id="impulse_duration" name="impulse_duration" value="10" min="1">
            <label for="impulse_time">Measurement Time (s):</label>
            <input type="number" id="impulse_time" name="impulse_time" value="0.1" min="0.001" step="0.001">
        </div>

        <!-- Testbed Settings -->
        <div id="settings_testbed" class="settings-group">
            <h3>Testbed Settings</h3>
            <label for="testbed_target_voltage">Target Output Voltage (V):</label>
            <input type="number" id="testbed_target_voltage" name="testbed_target_voltage" value="0" step="0.1" min="0" max="20">
            <label for="testbed_current_limit">Current Limit (A):</label>
            <input type="number" id="testbed_current_limit" name="testbed_current_limit" value="0.1" step="0.01" min="0" max="3">
            
            <h4>Live Readings:</h4>
            <div>Output Voltage: <span id="tb_out_v">-</span> V</div>
            <div>Output Current: <span id="tb_out_c">-</span> A</div>
            <div>Input CH0: <span id="tb_in_ch0">-</span> V</div>
            <div>Input CH1: <span id="tb_in_ch1">-</span> V</div>

            <h3 style="margin-top:16px;">Selected Applet Properties</h3>
            <div id="tb_props_none">Select an applet in the grid.</div>
            <div id="tb_props_panel" style="display:none;">
                <div><strong>Type:</strong> <span id="tb_prop_type"></span></div>
                <label for="tb_prop_bind">Bind Signal</label>
                <select id="tb_prop_bind">
                    <option value="output_voltage">Output Voltage</option>
                    <option value="output_current">Output Current</option>
                    <option value="input_ch0">Input CH0</option>
                    <option value="input_ch1">Input CH1</option>
                    <option value="da0">DA0</option>
                    <option value="da1">DA1</option>
                    <option value="da2">DA2</option>
                    <option value="da3">DA3</option>
                    <option value="db0">DB0</option>
                    <option value="db1">DB1</option>
                    <option value="db2">DB2</option>
                    <option value="db3">DB3</option>
                </select>

                <div id="tb_prop_minmax" style="display:none;">
                    <label for="tb_prop_min">Min</label>
                    <input id="tb_prop_min" type="number" step="0.01">
                    <label for="tb_prop_max">Max</label>
                    <input id="tb_prop_max" type="number" step="0.01">
                </div>
                <div id="tb_prop_timewin" style="display:none;">
                    <label for="tb_prop_time">Graph Length (s)</label>
                    <input id="tb_prop_time" type="number" step="0.5" min="1" value="10">
                </div>
                <div id="tb_prop_slider_target" style="display:none;">
                    <label for="tb_prop_slider_for">Slider Controls</label>
                    <select id="tb_prop_slider_for">
                        <option value="target_voltage">Target Voltage</option>
                        <option value="current_limit">Current Limit</option>
                    </select>
                </div>
                <div id="tb_prop_button_opts" style="display:none;">
                    <label for="tb_prop_bus">Pin Group</label>
                    <select id="tb_prop_bus">
                        <option value="da">DA</option>
                        <option value="db">DB</option>
                    </select>
                    <label for="tb_prop_pin">Pin Index</label>
                    <select id="tb_prop_pin">
                        <option value="0">0</option>
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>
                    <label for="tb_prop_button_mode">Mode</label>
                    <select id="tb_prop_button_mode">
                        <option value="toggle">Toggle</option>
                        <option value="click">Click</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Control Systems Toolbox Settings -->
        <div id="settings_control_system" class="settings-group">
            <h3>Control Systems Toolbox</h3>
            <label for="cs_mode">Mode:</label>
            <select id="cs_mode" name="cs_mode">
                <option value="controller">Device as Controller</option>
                <option value="system">Device as Controlled System</option>
            </select>

            <!-- Controller Specific Settings -->
            <div id="cs_controller_sub_settings">
                <label for="cs_controller_type">Controller Type:</label>
                <select id="cs_controller_type" name="cs_controller_type">
                    <option value="pid">PID Controller</option>
                    <option value="other">Other (from .ctl file)</option>
                </select>

                <div id="cs_pid_settings">
                    <h4>PID Parameters:</h4>
                    <label for="cs_pid_kp">Kp:</label>
                    <input type="number" id="cs_pid_kp" name="cs_pid_kp" value="1.0" step="0.01">
                    <label for="cs_pid_ki">Ki:</label>
                    <input type="number" id="cs_pid_ki" name="cs_pid_ki" value="0.1" step="0.01">
                    <label for="cs_pid_kd">Kd:</label>
                    <input type="number" id="cs_pid_kd" name="cs_pid_kd" value="0.01" step="0.001">
                </div>

                <!-- File Upload for Controller .ctl files -->
                <div id="cs_controller_file_upload_section" style="display: none;">
                    <h4>Controller File Upload:</h4>
                    <label for="cs_model_file_input">Upload Control Law File (.ctl):</label>
                    <input type="file" id="cs_model_file_input" name="cs_model_file_input" accept=".ctl">
                    <button type="button" id="cs_upload_button">Upload Model</button>
                </div>
            </div>

            <!-- System Specific Settings -->
            <div id="cs_system_sub_settings" style="display: none;">
                <h4>System Model Upload:</h4>
                <label for="cs_system_file_input">Upload System Model File (.mdl):</label>
                <input type="file" id="cs_system_file_input" name="cs_system_file_input" accept=".mdl">
                <button type="button" id="cs_system_upload_button">Upload Model</button>
            </div>

            <!-- Status Display -->
            <div id="cs_status_display">
                <div>Status: <span id="cs_status_text">No model uploaded</span></div>
                <div>Model Name: <span id="cs_model_name_text">-</span></div>
            </div>
        </div>


        <button id="measure_button">Measure</button>
        <button id="export_csv_button" disabled>Export CSV</button>
        <div id="export_dialog" style="display:none; position:absolute; left:10px; bottom:20px; width:240px; background:#222; padding:12px; border:1px solid #444; border-radius:6px; z-index:1000;">
            <strong style="display:block; margin-bottom:8px;">Export Options</strong>
            <label style="display:block; font-size:12px; margin-bottom:4px;">Decimal Separator:</label>
            <div style="font-size:12px; margin-bottom:8px;">
                <label><input type="radio" name="dec_sep" value="dot" checked> Dot (.) & comma CSV</label><br>
                <label><input type="radio" name="dec_sep" value="comma"> Comma (,) & semicolon CSV</label>
            </div>
            <div style="font-size:12px; margin-bottom:8px;">
                <label for="export_filename">File name:</label>
                <input id="export_filename" type="text" value="measurement_data" style="width:100%; box-sizing:border-box;">
            </div>
            <div style="display:flex; gap:8px; justify-content:flex-end;">
                <button type="button" id="export_cancel_btn" style="background:#555;">Cancel</button>
                <button type="button" id="export_save_btn">Save</button>
            </div>
        </div>
        <a href="{{ url_for('main.logout') }}" style="color: white; text-align: center; margin-top: 20px; display: block;">Logout</a>
    </div>
    <div class="main-content">
        <div id="graph" class="graph-container"></div>
        <div id="testbed_grid" class="testbed-grid" style="display:none;"></div>
    </div>

    <script>
        const measureButton = document.getElementById('measure_button');
        const exportCsvButton = document.getElementById('export_csv_button');
        const measureModeSelect = document.getElementById('measure_mode');
        const graphDiv = document.getElementById('graph');
        const testbedGrid = document.getElementById('testbed_grid');
        let currentChartData = null;
        let isContinuousRunning = false; // Track state for continuous modes
        let currentProgress = 0; // Track progress for non-continuous modes
        let continuousDataInterval = null; // Interval for polling continuous data
        let continuousDataBuffer = {
            timestamps: [],
            inputs: [],
            states_x1: [],
            states_x2: [],
            outputs_y1: [],
            outputs_y2: []
        };

        const vaChannelSelect = document.getElementById('va_channel');
        const vaModeTypeSelect = document.getElementById('va_mode_type');
        const vaCvSettingsDiv = document.getElementById('va_cv_settings');
        const vaCcSettingsDiv = document.getElementById('va_cc_settings');

        const allSettingsGroups = document.querySelectorAll('.settings-group');

        // Control System specific elements
        const csModeSelect = document.getElementById('cs_mode');
        const csControllerSettingsDiv = document.getElementById('cs_controller_settings');
        const csSystemSettingsDiv = document.getElementById('cs_system_settings');

        // New Control System Elements
        const csControllerSubSettingsDiv = document.getElementById('cs_controller_sub_settings');
        const csSystemSubSettingsDiv = document.getElementById('cs_system_sub_settings');
        const csControllerTypeSelect = document.getElementById('cs_controller_type');
        const csPidSettingsDiv = document.getElementById('cs_pid_settings');
        const csFileUploadLabel = document.getElementById('cs_file_upload_label');
        const csModelFileInput = document.getElementById('cs_model_file_input');
        const csSystemFileInput = document.getElementById('cs_system_file_input');
        const csUploadButton = document.getElementById('cs_upload_button');
        const csSystemUploadButton = document.getElementById('cs_system_upload_button');
        const csFileUploadSection = document.getElementById('cs_file_upload_section');
        const csControllerFileUploadSection = document.getElementById('cs_controller_file_upload_section');
        const csStatusDisplay = document.getElementById('cs_status_display');
        const targetBoardSelect = document.getElementById('target_board');

        let uploadedModelData = null; // Store uploaded model data

        // Testbed applets and runtime config
        let testbedApplets = [];
        let selectedAppletId = null;
        let testbedConfig = {
            target_voltage: 0,
            current_limit: 0.1,
            continuous_monitoring: true,
            update_interval_ms: 100,
            da: [ {mode:'analog', value:0}, {mode:'analog', value:0}, {mode:'analog', value:0}, {mode:'analog', value:0} ],
            db: [ {mode:'digital', value:0}, {mode:'digital', value:0}, {mode:'digital', value:0}, {mode:'digital', value:0} ]
        };

        function renderTestbedGrid() {
            testbedGrid.innerHTML = '';
            testbedApplets.forEach(ap => {
                const el = document.createElement('div');
                el.className = 'applet-card';
                el.dataset.appletId = ap.id;
                if (selectedAppletId === ap.id) el.classList.add('selected');

                const header = document.createElement('div');
                header.className = 'applet-header';
                header.textContent = `${ap.type.toUpperCase()} - ${ap.bind}`;
                el.appendChild(header);

                const body = document.createElement('div');
                body.className = 'applet-body';

                if (ap.type === 'gauge') {
                    const val = document.createElement('div');
                    val.className = 'applet-gauge-value';
                    val.textContent = '-';
                    body.appendChild(val);
                    const bar = document.createElement('div');
                    bar.className = 'applet-gauge-bar';
                    const fill = document.createElement('div');
                    fill.className = 'applet-gauge-fill';
                    bar.appendChild(fill);
                    body.appendChild(bar);
                } else if (ap.type === 'graph') {
                    const c = document.createElement('div');
                    c.className = 'applet-graph-canvas';
                    body.appendChild(c);
                    ap._series = ap._series || [];
                } else if (ap.type === 'slider') {
                    const input = document.createElement('input');
                    input.type = 'range';
                    input.min = ap.min ?? 0;
                    input.max = ap.max ?? (ap.sliderFor === 'current_limit' ? 3 : 20);
                    input.step = ap.sliderFor === 'current_limit' ? 0.01 : 0.1;
                    input.value = ap.sliderFor === 'current_limit' ? testbedConfig.current_limit : testbedConfig.target_voltage;
                    const readout = document.createElement('div');
                    readout.className = 'applet-slider-readout';
                    readout.textContent = input.value;
                    input.addEventListener('input', () => { readout.textContent = input.value; });
                    input.addEventListener('change', () => {
                        if (ap.sliderFor === 'current_limit') {
                            testbedConfig.current_limit = parseFloat(input.value);
                            sendTestbedSettings({ current_limit: testbedConfig.current_limit });
                            const cl = document.getElementById('testbed_current_limit'); if (cl) cl.value = testbedConfig.current_limit;
                        } else {
                            testbedConfig.target_voltage = parseFloat(input.value);
                            sendTestbedSettings({ target_voltage: testbedConfig.target_voltage });
                            const tv = document.getElementById('testbed_target_voltage'); if (tv) tv.value = testbedConfig.target_voltage;
                        }
                    });
                    body.appendChild(input);
                    body.appendChild(readout);
                } else if (ap.type === 'button') {
                    const b = document.createElement('button');
                    b.className = 'applet-action-button';
                    b.textContent = `${ap.bus?.toUpperCase() || 'DB'}${ap.pin ?? 0}`;
                    b.addEventListener('click', async () => {
                        if (ap.buttonMode === 'click') {
                            await setDigital(ap.bus, ap.pin, 3.3);
                            setTimeout(() => setDigital(ap.bus, ap.pin, 0), 200);
                        } else {
                            const cur = getPinValue(ap.bus, ap.pin) > 1.65 ? 3.3 : 0;
                            const next = cur > 0 ? 0 : 3.3;
                            await setDigital(ap.bus, ap.pin, next);
                            updateButtonColor(b, next);
                        }
                    });
                    updateButtonColor(b, getPinValue(ap.bus, ap.pin));
                    body.appendChild(b);
                } else if (ap.type === 'status') {
                    const s = document.createElement('div');
                    s.className = 'status-light';
                    s.textContent = `${ap.bus?.toUpperCase() || 'DB'}${ap.pin ?? 0}`;
                    body.appendChild(s);
                }

                el.appendChild(body);
                el.addEventListener('click', () => selectApplet(ap.id));
                testbedGrid.appendChild(el);
            });
        }

        function updateButtonColor(btn, value) {
            if (!btn) return;
            btn.classList.toggle('on', value > 1.65);
        }
        function getBusArray(bus) { return bus === 'da' ? testbedConfig.da : testbedConfig.db; }
        function getPinValue(bus, pin) { const a = getBusArray(bus); return (a[pin]?.value) || 0; }
        async function setDigital(bus, pin, value) {
            const arr = getBusArray(bus);
            arr[pin] = { mode: 'digital', value: value };
            const patch = {}; patch[bus] = arr; await sendTestbedSettings(patch);
        }
        function selectApplet(id) {
            selectedAppletId = id; renderTestbedGrid();
            const ap = testbedApplets.find(a => a.id === id); if (!ap) return;
            document.getElementById('tb_props_none').style.display = 'none';
            document.getElementById('tb_props_panel').style.display = 'block';
            document.getElementById('tb_prop_type').textContent = ap.type;
            const bindSel = document.getElementById('tb_prop_bind'); bindSel.value = ap.bind;
            document.getElementById('tb_prop_minmax').style.display = (ap.type === 'gauge' || ap.type === 'slider') ? 'block' : 'none';
            document.getElementById('tb_prop_timewin').style.display = (ap.type === 'graph') ? 'block' : 'none';
            document.getElementById('tb_prop_slider_target').style.display = (ap.type === 'slider') ? 'block' : 'none';
            document.getElementById('tb_prop_button_opts').style.display = (ap.type === 'button' || ap.type === 'status') ? 'block' : 'none';
            const pmn = document.getElementById('tb_prop_min'); if (pmn) pmn.value = ap.min ?? '';
            const pmx = document.getElementById('tb_prop_max'); if (pmx) pmx.value = ap.max ?? '';
            const pt = document.getElementById('tb_prop_time'); if (pt) pt.value = ap.timeWindow ?? 10;
            const ps = document.getElementById('tb_prop_slider_for'); if (ps) ps.value = ap.sliderFor ?? 'target_voltage';
            const pbus = document.getElementById('tb_prop_bus'); if (pbus) pbus.value = ap.bus ?? 'db';
            const ppin = document.getElementById('tb_prop_pin'); if (ppin) ppin.value = ap.pin ?? 0;
            const pbm = document.getElementById('tb_prop_button_mode'); if (pbm) pbm.value = ap.buttonMode ?? 'toggle';
        }
        ;['tb_prop_bind','tb_prop_min','tb_prop_max','tb_prop_time','tb_prop_slider_for','tb_prop_bus','tb_prop_pin','tb_prop_button_mode']
          .forEach(id => { const el = document.getElementById(id); if (!el) return; el.addEventListener('change', () => {
              const ap = testbedApplets.find(a => a.id === selectedAppletId); if (!ap) return;
              if (id==='tb_prop_bind') ap.bind = el.value;
              if (id==='tb_prop_min') ap.min = parseFloat(el.value);
              if (id==='tb_prop_max') ap.max = parseFloat(el.value);
              if (id==='tb_prop_time') ap.timeWindow = parseFloat(el.value);
              if (id==='tb_prop_slider_for') ap.sliderFor = el.value;
              if (id==='tb_prop_bus') ap.bus = el.value;
              if (id==='tb_prop_pin') ap.pin = parseInt(el.value);
              if (id==='tb_prop_button_mode') ap.buttonMode = el.value;
              renderTestbedGrid();
          });});

        function initTestbedGrid() {
            if (testbedApplets.length > 0) { testbedGrid.style.display = 'grid'; graphDiv.style.display = 'none'; renderTestbedGrid(); return; }
            testbedApplets = [
                { id: 'g_v', type: 'gauge', bind: 'output_voltage', min: 0, max: 20 },
                { id: 'g_c', type: 'gauge', bind: 'output_current', min: 0, max: 3 },
                { id: 'gr_v', type: 'graph', bind: 'output_voltage', timeWindow: 10 },
                { id: 's_tv', type: 'slider', bind: 'target_voltage', sliderFor: 'target_voltage', min: 0, max: 20 },
                { id: 's_cl', type: 'slider', bind: 'current_limit', sliderFor: 'current_limit', min: 0, max: 3 },
                { id: 'b_db0', type: 'button', bind: 'db0', bus: 'db', pin: 0, buttonMode: 'toggle' },
                { id: 'b_db1', type: 'button', bind: 'db1', bus: 'db', pin: 1, buttonMode: 'toggle' },
                { id: 'b_db2', type: 'button', bind: 'db2', bus: 'db', pin: 2, buttonMode: 'toggle' },
                { id: 'b_db3', type: 'button', bind: 'db3', bus: 'db', pin: 3, buttonMode: 'toggle' },
                { id: 'st_da0', type: 'status', bind: 'da0', bus: 'da', pin: 0 },
                { id: 'st_da1', type: 'status', bind: 'da1', bus: 'da', pin: 1 },
                { id: 'st_da2', type: 'status', bind: 'da2', bus: 'da', pin: 2 },
                { id: 'st_da3', type: 'status', bind: 'da3', bus: 'da', pin: 3 }
            ];
            selectedAppletId = null;
            testbedGrid.style.display = 'grid';
            graphDiv.style.display = 'none';
            renderTestbedGrid();
        }
        function teardownTestbedGrid() {
            testbedGrid.style.display = 'none';
            graphDiv.style.display = 'block';
        }
        async function sendTestbedSettings(patch) {
            testbedConfig = { ...testbedConfig, ...patch };
            const settings = {
                target_voltage: testbedConfig.target_voltage,
                current_limit: testbedConfig.current_limit,
                continuous_monitoring: true,
                update_interval_ms: testbedConfig.update_interval_ms,
                da: testbedConfig.da,
                db: testbedConfig.db
            };
            const fd = new FormData();
            fd.append('measure_mode', 'testbed');
            fd.append('target_board', targetBoardSelect.value);
            fd.append('no_flush', '1');
            fd.append('testbed_settings_json', JSON.stringify(settings));
            try { await fetch("{{ url_for('main.measure') }}", { method: 'POST', body: fd }); } catch(e) { console.error('Failed to send testbed settings', e); }
        }

        function updateTestbedApplets(data) {
            const r = data.readings || {};
            const daVals = r.da || [0,0,0,0];
            const dbVals = r.db || [0,0,0,0];
            testbedApplets.forEach(ap => {
                const el = testbedGrid.querySelector(`[data-applet-id="${ap.id}"]`);
                if (!el) return;
                const body = el.querySelector('.applet-body');
                if (ap.type === 'gauge') {
                    const valEl = body.querySelector('.applet-gauge-value');
                    const fill = body.querySelector('.applet-gauge-fill');
                    const value = readBinding(ap.bind, r, daVals, dbVals);
                    if (value != null && valEl && fill) {
                        valEl.textContent = value.toFixed(3);
                        const min = (ap.min ?? 0);
                        const max = (ap.max ?? 20);
                        const pct = Math.max(0, Math.min(1, (value - min) / (max - min || 1)));
                        fill.style.width = (pct * 100) + '%';
                    }
                } else if (ap.type === 'graph') {
                    const canvas = body.querySelector('.applet-graph-canvas');
                    const value = readBinding(ap.bind, r, daVals, dbVals);
                    const now = Date.now() / 1000;
                    ap._series = ap._series || [];
                    if (value != null) ap._series.push({ t: now, v: value });
                    const win = ap.timeWindow ?? 10;
                    ap._series = ap._series.filter(p => p.t >= now - win);
                    drawSparkline(canvas, ap._series, ap.min ?? 0, ap.max ?? (ap.bind.includes('current') ? 3 : 20));
                } else if (ap.type === 'button') {
                    const btn = body.querySelector('button');
                    const value = (ap.bus === 'da' ? daVals[ap.pin] : dbVals[ap.pin]) || 0;
                    updateButtonColor(btn, value);
                } else if (ap.type === 'status') {
                    const s = body.querySelector('.status-light');
                    const value = (ap.bus === 'da' ? daVals[ap.pin] : dbVals[ap.pin]) || 0;
                    if (s) s.classList.toggle('on', value > 1.65);
                }
            });
        }
        function readBinding(bind, r, daVals, dbVals) {
            if (bind === 'output_voltage') return r.output_voltage;
            if (bind === 'output_current') return r.output_current;
            if (bind === 'input_ch0') return r.input_ch0;
            if (bind === 'input_ch1') return r.input_ch1;
            if (bind && bind.startsWith('da')) return daVals[parseInt(bind.slice(2))] || 0;
            if (bind && bind.startsWith('db')) return dbVals[parseInt(bind.slice(2))] || 0;
            return null;
        }
        function drawSparkline(container, series, min, max) {
            if (!container) return;
            const w = container.clientWidth || 180;
            const h = container.clientHeight || 80;
            const xmin = series.length ? series[0].t : 0;
            const xmax = series.length ? series[series.length - 1].t : 1;
            const pts = series.map(p => {
                const x = (w * (p.t - xmin)) / ((xmax - xmin) || 1);
                const y = h - (h * (p.v - min)) / ((max - min) || 1);
                return `${x.toFixed(1)},${y.toFixed(1)}`;
            }).join(' ');
            container.innerHTML = `<svg width="100%" height="100%" viewBox="0 0 ${w} ${h}"><polyline fill="none" stroke="#007bff" stroke-width="2" points="${pts}" /></svg>`;
        }

        function updateMeasureButtonText() {
            const selectedMode = measureModeSelect.value;
            const csModeValue = csModeSelect ? csModeSelect.value : null;
            
            if (isContinuousRunning) {
                // Button shows "Stop" for all modes when running
                if (selectedMode === 'testbed') {
                    measureButton.textContent = 'Stop Testbed';
                } else if (selectedMode === 'control_system') {
                    if (csModeValue === 'controller') {
                        measureButton.textContent = 'Stop Controller';
                    } else {
                        measureButton.textContent = 'Stop System';
                    }
                } else if (['va','bode','step','impulse'].includes(selectedMode)) {
                    // Show progress bar behavior on the button for non-continuous modes
                    setButtonProgress(currentProgress);
                } else {
                    measureButton.textContent = 'Stop';
                }
            } else {
                // Button shows "Start" for continuous modes, "Measure" for others
                if (selectedMode === 'testbed') {
                    measureButton.textContent = 'Start Testbed';
                } else if (selectedMode === 'control_system') {
                    if (csModeValue === 'controller') {
                        measureButton.textContent = 'Start Controller';
                    } else {
                        measureButton.textContent = 'Start System';
                    }
                } else if (['va', 'bode', 'step', 'impulse'].includes(selectedMode)) {
                    measureButton.textContent = 'Start ' + selectedMode.toUpperCase();
                    resetButtonProgress();
                } else {
                    measureButton.textContent = 'Measure';
                }
            }
        }

        function setButtonProgress(progressPct) {
            const pct = Math.max(0, Math.min(100, progressPct || 0));
            measureButton.textContent = `Stop ${measureModeSelect.value.toUpperCase()} — ${pct.toFixed(1)}%`;
            measureButton.style.position = 'relative';
            measureButton.style.backgroundImage = `linear-gradient(90deg, rgba(0,123,255,0.35) ${pct}%, transparent ${pct}%)`;
            measureButton.style.transition = 'background-image 0.2s ease';
        }
        function resetButtonProgress() {
            currentProgress = 0;
            measureButton.style.backgroundImage = '';
        }

        function startContinuousDataPolling(boardId, mode) {
            console.log(`[DEBUG] Starting continuous data polling for board: ${boardId}, mode: ${mode}`);
            
            // Clear any existing interval
            if (continuousDataInterval) {
                clearInterval(continuousDataInterval);
            }

            // Clear data buffer for control system mode
            if (mode === 'control_system') {
                continuousDataBuffer = {
                    timestamps: [],
                    inputs: [],
                    states_x1: [],
                    states_x2: [],
                    outputs_y1: [],
                    outputs_y2: []
                };
            }

            // Poll for new data every 200ms for continuous modes, 1000ms for measurement modes
            const pollInterval = (mode === 'control_system' || mode === 'testbed') ? 200 : 1000;
            
            continuousDataInterval = setInterval(async () => {
                try {
                    const response = await fetch(`{{ url_for('main.get_continuous_data') }}?board_id=${boardId}&mode=${mode}`);
                    const data = await response.json();
                    
                    if (mode === 'control_system') {
                        // Handle control system data (array of data packets)
                        if (data && data.length > 0) {
                            data.forEach(dataPacket => {
                                if (dataPacket.type === 'data' && dataPacket.mode === 'control_system') {
                                    const payload = dataPacket.payload;
                                    console.log(`[DEBUG] Processing control system data packet with ${payload.sample_count} samples`);
                                    
                                    // Add new data to buffer
                                    continuousDataBuffer.timestamps.push(...payload.timestamps);
                                    continuousDataBuffer.inputs.push(...payload.inputs);
                                    continuousDataBuffer.states_x1.push(...payload.states_x1);
                                    continuousDataBuffer.states_x2.push(...payload.states_x2);
                                    continuousDataBuffer.outputs_y1.push(...payload.outputs_y1);
                                    continuousDataBuffer.outputs_y2.push(...payload.outputs_y2);
                                    
                                    // Keep only the last 1000 points for performance
                                    const maxPoints = 1000;
                                    if (continuousDataBuffer.timestamps.length > maxPoints) {
                                        const excess = continuousDataBuffer.timestamps.length - maxPoints;
                                        continuousDataBuffer.timestamps = continuousDataBuffer.timestamps.slice(excess);
                                        continuousDataBuffer.inputs = continuousDataBuffer.inputs.slice(excess);
                                        continuousDataBuffer.states_x1 = continuousDataBuffer.states_x1.slice(excess);
                                        continuousDataBuffer.states_x2 = continuousDataBuffer.states_x2.slice(excess);
                                        continuousDataBuffer.outputs_y1 = continuousDataBuffer.outputs_y1.slice(excess);
                                        continuousDataBuffer.outputs_y2 = continuousDataBuffer.outputs_y2.slice(excess);
                                    }
                                    
                                    // Update the graph
                                    updateContinuousGraph();
                                }
                            });
                        }
                    } else if (mode === 'testbed') {
                        // Handle testbed data (single object with readings)
                        if (data && data.mode === 'testbed' && data.readings) {
                            console.log(`[DEBUG] Processing testbed data`);
                            // Update testbed displays
                            document.getElementById('tb_out_v').textContent = data.readings.output_voltage !== undefined ? data.readings.output_voltage.toFixed(3) : '-';
                            document.getElementById('tb_out_c').textContent = data.readings.output_current !== undefined ? data.readings.output_current.toFixed(4) : '-';
                            document.getElementById('tb_in_ch0').textContent = data.readings.input_ch0 !== undefined ? data.readings.input_ch0.toFixed(3) : '-';
                            document.getElementById('tb_in_ch1').textContent = data.readings.input_ch1 !== undefined ? data.readings.input_ch1.toFixed(3) : '-';
                            // Update the grid applets
                            updateTestbedApplets(data);
                        }
                    } else if (mode === 'va') {
                        // Handle VA measurement data (accumulated data points)
                        if (data && data.mode === 'va' && data.data && data.data.length > 0) {
                            console.log(`[DEBUG] Processing VA data: ${data.data.length} points, ${data.progress}% complete`);
                            currentProgress = data.progress || 0;
                            setButtonProgress(currentProgress);
                            // Update the VA plot
                            const plot = {
                                x: data.data.map(p => p.voltage),
                                y: data.data.map(p => p.current),
                                type: 'scatter',
                                mode: 'lines+markers'
                            };
                            const layout = {
                                margin: { t: 30, b: 50, l: 60, r: 30 },
                                xaxis: { title: 'Voltage (V)' },
                                yaxis: { title: 'Current (A)' },
                                title: `VA Characteristics - ${data.progress.toFixed(1)}% Complete`
                            };
                            Plotly.newPlot(graphDiv, [plot], layout);
                            
                            // Stop polling if measurement is complete
                            if (data.completed) {
                                console.log('[DEBUG] VA measurement completed');
                                stopContinuousDataPolling();
                                isContinuousRunning = false;
                                resetButtonProgress();
                                updateMeasureButtonText();
                                layout.title = 'VA Characteristics - Complete';
                                Plotly.newPlot(graphDiv, [plot], layout);
                            }
                        }
                    } else if (['bode', 'step', 'impulse'].includes(mode)) {
                        // Handle other measurement modes similarly to VA
                        if (data && data.mode === mode && data.data && data.data.length > 0) {
                            console.log(`[DEBUG] Processing ${mode} data: ${data.data.length} points, ${data.progress}% complete`);
                            currentProgress = data.progress || 0;
                            setButtonProgress(currentProgress);
                            
                            let plot, layout;
                            if (mode === 'bode') {
                                const trace1 = {
                                    x: data.data.map(p => p.frequency),
                                    y: data.data.map(p => p.gain),
                                    name: 'Gain (dB)',
                                    type: 'scatter',
                                    mode: 'lines+markers'
                                };
                                const trace2 = {
                                    x: data.data.map(p => p.frequency),
                                    y: data.data.map(p => p.phase),
                                    name: 'Phase (°)',
                                    yaxis: 'y2',
                                    type: 'scatter',
                                    mode: 'lines+markers'
                                };
                                plot = [trace1, trace2];
                                layout = {
                                    margin: { t: 30, b: 50, l: 60, r: 30 },
                                    xaxis: { title: 'Frequency (Hz)', type: 'log' },
                                    yaxis: { title: 'Gain (dB)' },
                                    yaxis2: { title: 'Phase (°)', overlaying: 'y', side: 'right', showgrid: false },
                                    title: `Bode Plot - ${data.progress.toFixed(1)}% Complete`
                                };
                            } else {
                                plot = {
                                    x: data.data.map(p => p.time),
                                    y: data.data.map(p => p.response),
                                    type: 'scatter',
                                    mode: 'lines'
                                };
                                layout = {
                                    margin: { t: 30, b: 50, l: 60, r: 30 },
                                    xaxis: { title: 'Time (s)' },
                                    yaxis: { title: 'Response (V)' },
                                    title: `${mode.charAt(0).toUpperCase() + mode.slice(1)} Response - ${data.progress.toFixed(1)}% Complete`
                                };
                            }
                            
                            Plotly.newPlot(graphDiv, plot, layout);
                            
                            // Stop polling if measurement is complete
                            if (data.completed) {
                                console.log(`[DEBUG] ${mode} measurement completed`);
                                stopContinuousDataPolling();
                                isContinuousRunning = false;
                                resetButtonProgress();
                                updateMeasureButtonText();
                                layout.title = layout.title.replace(/- \d+.*% Complete/, '- Complete');
                                Plotly.newPlot(graphDiv, plot, layout);
                            }
                        }
                    }
                } catch (error) {
                    console.error(`[DEBUG] Error polling continuous data for ${mode}:`, error);
                }
            }, pollInterval);
        }

        function stopContinuousDataPolling() {
            console.log('[DEBUG] Stopping continuous data polling');
            if (continuousDataInterval) {
                clearInterval(continuousDataInterval);
                continuousDataInterval = null;
            }
        }

        function updateContinuousGraph() {
            if (continuousDataBuffer.timestamps.length === 0) return;

            // Convert timestamps to relative time in seconds
            const firstTimestamp = continuousDataBuffer.timestamps[0];
            const timeSeconds = continuousDataBuffer.timestamps.map(t => (t - firstTimestamp) / 1000.0);

            const traces = [
                {
                    x: timeSeconds,
                    y: continuousDataBuffer.inputs,
                    name: getInputName(1),
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'blue' }
                },
                {
                    x: timeSeconds,
                    y: continuousDataBuffer.states_x1,
                    name: 'State X1',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'red' }
                },
                {
                    x: timeSeconds,
                    y: continuousDataBuffer.states_x2,
                    name: 'State X2',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'green' }
                },
                {
                    x: timeSeconds,
                    y: continuousDataBuffer.outputs_y1,
                    name: getOutputName(1),
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'orange', dash: 'dot' }
                },
                {
                    x: timeSeconds,
                    y: continuousDataBuffer.outputs_y2,
                    name: getOutputName(2),
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'purple', dash: 'dot' }
                }
            ];

            const layout = {
                margin: { t: 30, b: 50, l: 60, r: 30 },
                xaxis: { title: 'Time (s)' },
                yaxis: { title: 'Value' },
                title: 'Control System - Real-time Data',
                showlegend: true,
                legend: { x: 0, y: 1 }
            };

            Plotly.newPlot(graphDiv, traces, layout);
        }

        function startMeasurementDataPolling(boardId, mode) {
            console.log(`[DEBUG] Starting measurement data polling for board: ${boardId}, mode: ${mode}`);
            
            // Clear any existing interval
            if (continuousDataInterval) {
                clearInterval(continuousDataInterval);
            }

            // Poll for measurement data every 500ms for non-continuous modes
            continuousDataInterval = setInterval(async () => {
                try {
                    const response = await fetch(`{{ url_for('main.get_measurement_data') }}?board_id=${boardId}&mode=${mode}`);
                    const data = await response.json();
                    
                    if (data && data.data && data.data.length > 0) {
                        console.log(`[DEBUG] Received ${mode} measurement data: ${data.data.length} points, ${data.progress}% complete`);
                        
                        currentProgress = data.progress || 0;
                        setButtonProgress(currentProgress);
                        // Update export dataset and enable button when points arrive
                        currentChartData = data.data;
                        exportCsvButton.disabled = false;
                        // Plot the accumulated data - pass data.data (the array of points), not [data]
                        plotData(data.data, mode);
                        
                        // Check if measurement is complete
                        if (data.completed) {
                            console.log(`[DEBUG] ${mode} measurement completed`);
                            isContinuousRunning = false;
                            resetButtonProgress();
                            updateMeasureButtonText();
                            stopMeasurementDataPolling();
                        }
                    }
                } catch (error) {
                    console.error(`Error polling ${mode} data:`, error);
                }
            }, 500);
        }

        function stopMeasurementDataPolling() {
            console.log('[DEBUG] Stopping measurement data polling');
            if (continuousDataInterval) {
                clearInterval(continuousDataInterval);
                continuousDataInterval = null;
            }
        }

        async function fetchReadyBoards() {
            try {
                const response = await fetch("{{ url_for('main.get_boards') }}");
                const boards = await response.json();
                
                // Clear existing options
                targetBoardSelect.innerHTML = '';

                if (boards.length > 0) {
                    boards.forEach(board => {
                        const option = document.createElement('option');
                        option.value = board;
                        option.textContent = board;
                        targetBoardSelect.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = "";
                    option.textContent = "No ready boards found";
                    option.disabled = true;
                    targetBoardSelect.appendChild(option);
                }
            } catch (error) {
                console.error("Error fetching boards:", error);
            }
        }

        function updateSettingsVisibility() {
            const selectedMode = measureModeSelect.value;
            
            // Stop continuous polling when mode changes
            if (isContinuousRunning && continuousDataInterval) {
                stopContinuousDataPolling();
                isContinuousRunning = false;
            }
            
            allSettingsGroups.forEach(group => {
                group.classList.remove('active');
            });
            const activeSettingsGroup = document.getElementById('settings_' + selectedMode);
            if (activeSettingsGroup) {
                activeSettingsGroup.classList.add('active');
            }

            // VA specific logic for CC/CV
            if (selectedMode === 'va') {
                // Allow CV/CC for all channels; toggle sub-settings based on mode
                if (vaModeTypeSelect.value === 'CV') {
                    vaCvSettingsDiv.style.display = 'block';
                    vaCcSettingsDiv.style.display = 'none';
                } else {
                    vaCvSettingsDiv.style.display = 'none';
                    vaCcSettingsDiv.style.display = 'block';
                }
            }
            // Control System specific logic for sub-settings
            if (selectedMode === 'control_system' && csModeSelect) {
                if (csModeSelect.value === 'controller') {
                    csControllerSubSettingsDiv.style.display = 'block';
                    csSystemSubSettingsDiv.style.display = 'none';
                    csStatusDisplay.style.display = 'block';
                    
                    // Show/hide based on controller type
                    if (csControllerTypeSelect.value === 'pid') {
                        csPidSettingsDiv.style.display = 'block';
                        csControllerFileUploadSection.style.display = 'none';
                        // Reset status for PID mode
                        document.getElementById('cs_status_text').textContent = 'Using PID parameters';
                        document.getElementById('cs_model_name_text').textContent = 'PID Controller';
                    } else {
                        csPidSettingsDiv.style.display = 'none';
                        csControllerFileUploadSection.style.display = 'block';
                        // Reset status for file mode
                        document.getElementById('cs_status_text').textContent = 'No model uploaded';
                        document.getElementById('cs_model_name_text').textContent = '-';
                    }
                } else { // system
                    csControllerSubSettingsDiv.style.display = 'none';
                    csSystemSubSettingsDiv.style.display = 'block';
                    csPidSettingsDiv.style.display = 'none';
                    csStatusDisplay.style.display = 'block';
                    // Reset status for system mode
                    document.getElementById('cs_status_text').textContent = 'No model uploaded';
                    document.getElementById('cs_model_name_text').textContent = '-';
                }
            }
            // Switch graph/grid for testbed
            if (selectedMode === 'testbed') {
                initTestbedGrid();
            } else {
                teardownTestbedGrid();
            }
            
            // Update measure button text based on selected mode
            updateMeasureButtonText();
        }
        
        measureModeSelect.addEventListener('change', updateSettingsVisibility);
        if(vaChannelSelect) vaChannelSelect.addEventListener('change', updateSettingsVisibility);
        if(vaModeTypeSelect) vaModeTypeSelect.addEventListener('change', updateSettingsVisibility);
        if(csModeSelect) csModeSelect.addEventListener('change', updateSettingsVisibility); // Listener for CS mode change
        if(csControllerTypeSelect) csControllerTypeSelect.addEventListener('change', updateSettingsVisibility); // Listener for CS controller type change

        // Upload button functionality for controller files
        if(csUploadButton) {
            csUploadButton.addEventListener('click', async () => {
                const fileInput = document.getElementById('cs_model_file_input');
                if (!fileInput.files || fileInput.files.length === 0) {
                    document.getElementById('cs_status_text').textContent = 'No file selected';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    return;
                }

                const file = fileInput.files[0];
                console.log(`[DEBUG] Uploading controller file: ${file.name}, size: ${file.size}, type: ${file.type}`);

                if (!file.name.endsWith('.ctl')) {
                    document.getElementById('cs_status_text').textContent = 'Wrong file type. Expected .ctl';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    return;
                }

                try {
                    const text = await file.text();
                    const modelData = JSON.parse(text);
                    
                    console.log(`[DEBUG] Controller file parsed successfully:`, modelData);
                    
                    uploadedModelData = modelData;
                    document.getElementById('cs_status_text').textContent = 'Controller uploaded successfully';
                    document.getElementById('cs_model_name_text').textContent = modelData.controller_name || file.name;
                    
                } catch (error) {
                    console.error(`[DEBUG] Controller file parsing error:`, error);
                    document.getElementById('cs_status_text').textContent = 'Invalid file format';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    uploadedModelData = null;
                }
            });
        }

        // Upload button functionality for system files
        if(csSystemUploadButton) {
            csSystemUploadButton.addEventListener('click', async () => {
                const fileInput = document.getElementById('cs_system_file_input');
                if (!fileInput.files || fileInput.files.length === 0) {
                    document.getElementById('cs_status_text').textContent = 'No file selected';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    return;
                }

                const file = fileInput.files[0];
                console.log(`[DEBUG] Uploading system file: ${file.name}, size: ${file.size}, type: ${file.type}`);

                if (!file.name.endsWith('.mdl')) {
                    document.getElementById('cs_status_text').textContent = 'Wrong file type. Expected .mdl';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    return;
                }

                try {
                    const text = await file.text();
                    const modelData = JSON.parse(text);
                    
                    console.log(`[DEBUG] System file parsed successfully:`, modelData);
                    
                    uploadedModelData = modelData;
                    document.getElementById('cs_status_text').textContent = 'Model uploaded successfully';
                    document.getElementById('cs_model_name_text').textContent = modelData.system_name || file.name;
                    
                } catch (error) {
                    console.error(`[DEBUG] System file parsing error:`, error);
                    document.getElementById('cs_status_text').textContent = 'Invalid file format';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    uploadedModelData = null;
                }
            });
        }

        function getOutputName(outputIndex) {
            // Get output name from uploaded model data, fallback to default names
            if (uploadedModelData && uploadedModelData.output_mapping && uploadedModelData.output_mapping.length >= outputIndex) {
                const outputMapping = uploadedModelData.output_mapping[outputIndex - 1];
                return outputMapping?.output_name || `Output Y${outputIndex}`;
            }
            return `Output Y${outputIndex}`;
        }

        function getInputName(inputIndex) {
            // Get input name from uploaded model data, fallback to default names
            if (uploadedModelData && uploadedModelData.input_mapping && uploadedModelData.input_mapping.length >= inputIndex) {
                const inputMapping = uploadedModelData.input_mapping[inputIndex - 1];
                return inputMapping?.input_name || `Input ${inputIndex}`;
            }
            return `Input ${inputIndex}`;
        }

        measureButton.addEventListener('click', async () => {
            const mode = measureModeSelect.value;
            const targetBoard = document.getElementById('target_board').value;
            
            // Check if this is a continuous mode and if it's currently running
            const isContinuousMode = (mode === 'testbed' || mode === 'control_system');
            
            if (isContinuousMode && isContinuousRunning) {
                // Stop the continuous mode
                try {
                    const stopFormData = new FormData();
                    stopFormData.append('measure_mode', mode);
                    stopFormData.append('target_board', targetBoard);
                    
                    const response = await fetch("{{ url_for('main.stop') }}", {
                        method: 'POST',
                        body: stopFormData
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok) {
                        isContinuousRunning = false;
                        updateMeasureButtonText();
                        
                        // Clear any continuous data displays
                        if (mode === 'testbed') {
                            document.getElementById('tb_out_v').textContent = '-';
                            document.getElementById('tb_out_c').textContent = '-';
                            document.getElementById('tb_in_ch0').textContent = '-';
                            document.getElementById('tb_in_ch1').textContent = '-';
                        } else if (mode === 'control_system') {
                            // Stop continuous data polling
                            stopContinuousDataPolling();
                            
                            // Update status to show stopped
                            const currentStatus = document.getElementById('cs_status_text').textContent;
                            if (!currentStatus.includes('uploaded')) {
                                document.getElementById('cs_status_text').textContent = 'Stopped';
                            }
                        }
                        
                        // Keep graph data visible when stopped for review
                        console.log('[DEBUG] Measurement stopped, keeping graph data visible');
                        
                        console.log('Stopped:', data.message);
                    } else {
                        alert('Error stopping: ' + (data.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Stop error:', error);
                    alert('Failed to stop the measurement.');
                }
                return;
            }
            
            // Start measurement (original logic)
            const formData = new FormData();
            formData.append('measure_mode', mode);
            formData.append('target_board', targetBoard);

            // Collect data from the active settings group
            const activeSettingsGroup = document.querySelector('.settings-group.active');
            if (activeSettingsGroup && mode !== 'testbed') {
                const inputs = activeSettingsGroup.querySelectorAll('input[type="number"], input[type="text"], select'); // query for specific input types
                inputs.forEach(input => {
                    if (!input.disabled && input.name) { // only include enabled inputs with a name
                         formData.append(input.name, input.value);
                    }
                });
                // Handle file input - don't send file, send pre-uploaded model data
                const fileInput = activeSettingsGroup.querySelector('input[type="file"]');
                if (fileInput) {
                    // For control system mode with system, check if model data is available
                    if (mode === 'control_system' && formData.get('cs_mode') === 'system') {
                        if (uploadedModelData) {
                            // Send the model data directly as JSON string
                            formData.append('cs_model_data', JSON.stringify(uploadedModelData));
                            const systemFileInput = document.getElementById('cs_system_file_input');
                            formData.append('cs_model_file_input_name', systemFileInput.files[0]?.name || 'uploaded_model.mdl');
                        } else {
                            alert('Please upload a model file first using the Upload Model button.');
                            return;
                        }
                    } else if (mode === 'control_system' && formData.get('cs_mode') === 'controller' && formData.get('cs_controller_type') === 'other') {
                        if (uploadedModelData) {
                            // Send the controller data directly as JSON string
                            formData.append('cs_model_data', JSON.stringify(uploadedModelData));
                            const controllerFileInput = document.getElementById('cs_model_file_input');
                            formData.append('cs_model_file_input_name', controllerFileInput.files[0]?.name || 'uploaded_controller.ctl');
                        } else {
                            alert('Please upload a controller file first using the Upload Model button.');
                            return;
                        }
                    } else if (fileInput.files && fileInput.files.length > 0) {
                        formData.append(fileInput.name, fileInput.files[0]); // Send actual file for other modes
                        formData.append(fileInput.name + '_name', fileInput.files[0].name);
                    } else {
                        formData.append(fileInput.name + '_name', ''); // Send empty if no file selected
                    }
                }

                // Include shunt resistance in VA settings
                if (mode === 'va') {
                    const shunt = document.getElementById('va_shunt_resistance').value;
                    formData.set('va_shunt_resistance', shunt);
                }
            } else if (mode === 'testbed') {
                // Build MQTT-compliant testbed settings from current config
                testbedConfig.target_voltage = parseFloat(document.getElementById('testbed_target_voltage').value);
                testbedConfig.current_limit = parseFloat(document.getElementById('testbed_current_limit').value);
                const settings = {
                    mode: 'testbed',
                    target_voltage: testbedConfig.target_voltage,
                    current_limit: testbedConfig.current_limit,
                    continuous_monitoring: true,
                    update_interval_ms: testbedConfig.update_interval_ms,
                    da: testbedConfig.da,
                    db: testbedConfig.db
                };
                formData.append('testbed_settings_json', JSON.stringify(settings));
            }

            // Clear the graph before starting new measurement
            Plotly.newPlot(graphDiv, [], {
                margin: { t: 30, b: 50, l: 60, r: 30 },
                title: `${mode.toUpperCase()} - Starting...`
            });

            // Ensure testbed uses JSON settings per spec
            if (mode === 'testbed') {
                testbedConfig.target_voltage = parseFloat(document.getElementById('testbed_target_voltage').value);
                testbedConfig.current_limit = parseFloat(document.getElementById('testbed_current_limit').value);
                const tbSettings = {
                    target_voltage: testbedConfig.target_voltage,
                    current_limit: testbedConfig.current_limit,
                    continuous_monitoring: true,
                    update_interval_ms: testbedConfig.update_interval_ms,
                    da: testbedConfig.da,
                    db: testbedConfig.db
                };
                formData.append('testbed_settings_json', JSON.stringify(tbSettings));
            }

            try {
                const response = await fetch("{{ url_for('main.measure') }}", {
                    method: 'POST',
                    body: formData  // FormData automatically sets correct Content-Type with boundary
                });
                const data = await response.json();
                
                if (response.ok) {
                    // Start response may be a status object; actual points arrive via polling
                    plotData(data, mode);
                    // Enable export only when real data points arrive (handled in polling)
                    
                    // Update state for continuous modes
                    if (isContinuousMode) {
                        isContinuousRunning = true;
                        updateMeasureButtonText();
                        
                        // Start continuous data polling for control system mode
                        if (mode === 'control_system') {
                            startContinuousDataPolling(targetBoard, mode);
                        }
                    } else if (mode === 'testbed') {
                        // Testbed is continuous
                        isContinuousRunning = true;
                        updateMeasureButtonText();
                        startContinuousDataPolling(targetBoard, mode);
                    } else if (['va', 'bode', 'step', 'impulse'].includes(mode)) {
                        // These modes are non-continuous measurements with progress tracking
                        isContinuousRunning = true;
                        updateMeasureButtonText();
                        startMeasurementDataPolling(targetBoard, mode);
                    }
                } else {
                    alert('Error starting measurement: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Measure error:', error);
                alert('Failed to start measurement.');
            }
        });

        exportCsvButton.addEventListener('click', async () => {
            if (!currentChartData || currentChartData.length === 0) {
                alert('No data to export.');
                return;
            }
            const dialog = document.getElementById('export_dialog');
            dialog.style.display = 'block';
        });

        document.getElementById('export_cancel_btn').addEventListener('click', () => {
            document.getElementById('export_dialog').style.display = 'none';
        });

        document.getElementById('export_save_btn').addEventListener('click', async () => {
            const dialog = document.getElementById('export_dialog');
            const decSep = document.querySelector('input[name="dec_sep"]:checked').value; // 'dot' or 'comma'
            let filename = document.getElementById('export_filename').value.trim();
            if (!filename) filename = 'measurement_data';
            filename += '.csv';

            // Build CSV client-side for better formatting
            const decimalChar = decSep === 'comma' ? ',' : '.';
            const delimiter = decSep === 'comma' ? ';' : ',';

            function formatNumber(n) {
                if (typeof n !== 'number') return n === null || n === undefined ? '' : String(n);
                let s = n.toFixed(12).replace(/0+$/,'').replace(/\.$/,'');
                if (s === '' || s === '-') s = '0';
                if (decimalChar !== '.') s = s.replace('.', decimalChar);
                return s;
            }
            function isNumericField(val) {
                return typeof val === 'number';
            }
            let rows = [];
            if (Array.isArray(currentChartData) && currentChartData.length > 0) {
                const headers = Object.keys(currentChartData[0]);
                rows.push(headers.join(delimiter));
                currentChartData.forEach(obj => {
                    const row = headers.map(h => {
                        const v = obj[h];
                        const fv = isNumericField(v) ? formatNumber(v) : (v === null || v === undefined ? '' : String(v));
                        // Wrap if contains delimiter or newline
                        if (/["\n]/.test(fv) || fv.includes(delimiter)) {
                            return '"' + fv.replace(/"/g,'""') + '"';
                        }
                        return fv;
                    }).join(delimiter);
                    rows.push(row);
                });
            } else if (currentChartData && typeof currentChartData === 'object') {
                const headers = Object.keys(currentChartData);
                rows.push(headers.join(delimiter));
                const row = headers.map(h => {
                    const v = currentChartData[h];
                    const fv = isNumericField(v) ? formatNumber(v) : (v === null || v === undefined ? '' : String(v));
                    if (/["\n]/.test(fv) || fv.includes(delimiter)) {
                        return '"' + fv.replace(/"/g,'""') + '"';
                    }
                    return fv;
                }).join(delimiter);
                rows.push(row);
            } else {
                alert('Unsupported data format for export.');
                return;
            }

            const csvBlob = new Blob([rows.join('\n')], { type: 'text/csv' });

            // Attempt File System Access API first
            if (window.showSaveFilePicker) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: filename,
                        types: [{ description: 'CSV file', accept: { 'text/csv': ['.csv'] } }]
                    });
                    const writable = await handle.createWritable();
                    await writable.write(csvBlob);
                    await writable.close();
                    dialog.style.display = 'none';
                    return;
                } catch (e) {
                    console.warn('showSaveFilePicker failed, falling back', e);
                }
            }
            // Fallback to classic download
            const link = document.createElement('a');
            link.href = URL.createObjectURL(csvBlob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            dialog.style.display = 'none';
        });

        function plotData(data, mode) {
            let plot = {};
            let layout = {
                margin: { t: 30, b: 50, l: 60, r: 30 },
                xaxis: {},
                yaxis: {},
                yaxis2: {
                    overlaying: 'y',
                    side: 'right',
                    showgrid: false,
                },
                title: mode.toUpperCase() + ' Measurement' // Generic title
            };
            
            // Clear previous plot and specific displays
            Plotly.newPlot(graphDiv, [], layout); // Clear graph
            document.getElementById('tb_out_v').textContent = '-';
            document.getElementById('tb_out_c').textContent = '-';
            document.getElementById('tb_in_ch0').textContent = '-';
            document.getElementById('tb_in_ch1').textContent = '-';
            // Note: Don't clear cs_status_text and cs_model_name_text here as they show upload status

            if (!data || ((Array.isArray(data) && data.length === 0)) || (typeof data === 'object' && !data.type && Object.keys(data).length === 0) ) { // Adjusted condition for CS data
                return;
            }
            
            if (mode === 'va') {
                if (data.type === "va_started") {
                    // Handle VA measurement start
                    layout.title = 'VA Characteristics - Collecting Data...';
                    layout.xaxis.title = 'Voltage (V)';
                    layout.yaxis.title = 'Current (A)';
                    Plotly.newPlot(graphDiv, [], layout);
                    console.log('[DEBUG] VA measurement started, data collection will begin');
                } else if (Array.isArray(data) && data.length > 0) {
                    // Handle accumulated VA data
                    plot = {
                        x: data.map(p => p.voltage),
                        y: data.map(p => p.current),
                        type: 'scatter',
                        mode: 'lines+markers'
                    };
                    layout.xaxis.title = 'Voltage (V)';
                    layout.yaxis.title = 'Current (A)';
                    layout.title = 'VA Characteristics';
                    Plotly.newPlot(graphDiv, [plot], layout);
                } else {
                    // Default empty plot
                    layout.xaxis.title = 'Voltage (V)';
                    layout.yaxis.title = 'Current (A)';
                    layout.title = 'VA Characteristics';
                    Plotly.newPlot(graphDiv, [], layout);
                }
            } else if (mode === 'bode') {
                const trace1 = {
                    x: data.map(p => p.frequency),
                    y: data.map(p => p.gain),
                    name: 'Gain (dB)',
                    type: 'scatter',
                    mode: 'lines+markers'
                };
                const trace2 = {
                    x: data.map(p => p.frequency),
                    y: data.map(p => p.phase),
                    name: 'Phase (°)',
                    yaxis: 'y2',
                    type: 'scatter',
                    mode: 'lines+markers'
                };
                plot = [trace1, trace2];
                layout.xaxis.title = 'Frequency (Hz)';
                layout.xaxis.type = 'log';
                layout.yaxis.title = 'Gain (dB)';
                layout.yaxis2.title = 'Phase (°)';
                layout.title = 'Bode Plot';
                Plotly.newPlot(graphDiv, plot, layout);
            } else if (mode === 'step' || mode === 'impulse') {
                plot = {
                    x: data.map(p => p.time),
                    y: data.map(p => p.response),
                    type: 'scatter',
                    mode: 'lines'
                };
                layout.xaxis.title = 'Time (s)';
                layout.yaxis.title = 'Response (V)';
                layout.title = mode === 'step' ? 'Step Response' : 'Impulse Response';
                Plotly.newPlot(graphDiv, [plot], layout);
            } else if (mode === 'testbed') {
                // For testbed, show the grid and update sidebar readings
                document.getElementById('tb_out_v').textContent = data.output_voltage !== undefined ? data.output_voltage.toFixed(3) : '-';
                document.getElementById('tb_out_c').textContent = data.output_current !== undefined ? data.output_current.toFixed(4) : '-';
                document.getElementById('tb_in_ch0').textContent = data.input_ch0 !== undefined ? data.input_ch0.toFixed(3) : '-';
                document.getElementById('tb_in_ch1').textContent = data.input_ch1 !== undefined ? data.input_ch1.toFixed(3) : '-';
                initTestbedGrid();
                Plotly.purge(graphDiv);
            } else if (mode === 'control_system') {
                if (data.type === "pid_response" && data.data) {
                    plot = {
                        x: data.data.map(p => p.time),
                        y: data.data.map(p => p.response),
                        type: 'scatter',
                        mode: 'lines'
                    };
                    layout.xaxis.title = 'Time (s)';
                    layout.yaxis.title = 'System Response';
                    let params_str = "PID Params: " + Object.entries(data.params || {}).map(([k,v]) => `${k}=${v}`).join(', ');
                    // Update status but don't overwrite upload status
                    if (document.getElementById('cs_status_text').textContent.includes('uploaded')) {
                        document.getElementById('cs_status_text').textContent += ` | ${data.status || ""}`;
                    } else {
                        document.getElementById('cs_status_text').textContent = data.status || "";
                    }
                    layout.title = 'PID Controller Response';
                    Plotly.newPlot(graphDiv, [plot], layout);
                } else if (data.type === "control_system_started") {
                    // Handle the new control system started response
                    const statusText = data.message || "Control system started";
                    
                    // Update status but don't overwrite upload status
                    if (document.getElementById('cs_status_text').textContent.includes('uploaded')) {
                        document.getElementById('cs_status_text').textContent += ` | Running`;
                    } else {
                        document.getElementById('cs_status_text').textContent = statusText;
                    }
                    
                    // Set up initial empty graph for real-time data
                    layout.title = 'Control System - Real-time Data (Waiting for data...)';
                    layout.xaxis.title = 'Time (s)';
                    layout.yaxis.title = 'Value';
                    Plotly.newPlot(graphDiv, [], layout);
                    
                    console.log('[DEBUG] Control system started, real-time graphing will begin when data arrives');
                } else {
                    // Update status but don't overwrite upload status  
                    if (document.getElementById('cs_status_text').textContent.includes('uploaded')) {
                        document.getElementById('cs_status_text').textContent += ` | ${data.status || ""}`;
                    } else {
                        document.getElementById('cs_status_text').textContent = data.status || "";
                    }
                    layout.title = 'Control Systems Toolbox - Status';
                    Plotly.newPlot(graphDiv, [], layout); // Clear graph or show general status
                }
            }
        }
        // Initial setup
        updateSettingsVisibility();
        fetchReadyBoards(); // Fetch boards on page load
        setInterval(fetchReadyBoards, 5000); // Refresh board list every 5 seconds
    </script>
</body>
</html>
