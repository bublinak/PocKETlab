<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Measuring Device Frontend</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        .settings-group { display: none; } /* Initially hide all specific settings */
        .settings-group.active { display: block; } /* Show active settings */
    </style>
</head>
<body>
    <div class="sidebar">
        <h2>Settings</h2>
        <label for="target_board">Target Board:</label>
        <select id="target_board" name="target_board">
            <!-- Options will be populated dynamically -->
        </select>

        <label for="measure_mode">Measure Mode:</label>
        <select id="measure_mode" name="measure_mode">
            <option value="va">VA Characteristics</option>
            <option value="bode">Frequency/Phase Response (Bode)</option>
            <option value="step">Step Response</option>
            <option value="impulse">Impulse Response</option>
            <option value="testbed">Testbed</option>
            <option value="control_system">Control Systems Toolbox</option>
        </select>

        <!-- VA Characteristics Settings -->
        <div id="settings_va" class="settings-group">
            <h3>VA Settings</h3>
            <label for="va_channel">Channel:</label>
            <select id="va_channel" name="va_channel">
                <option value="CH0">CH0 (CV Only)</option>
                <option value="CH1">CH1 (CV Only)</option>
                <option value="CH2">CH2 (CV/CC)</option>
            </select>
            <label for="va_mode_type">Mode (CH2 Only):</label>
            <select id="va_mode_type" name="va_mode_type" disabled>
                <option value="CV">CV (Constant Voltage)</option>
                <option value="CC">CC (Constant Current)</option>
            </select>
            <div id="va_cv_settings">
                <label for="va_start_voltage">Start Voltage (V):</label>
                <input type="number" id="va_start_voltage" name="va_start_voltage" value="0" step="0.1">
                <label for="va_end_voltage">End Voltage (V):</label>
                <input type="number" id="va_end_voltage" name="va_end_voltage" value="5" step="0.1">
                <label for="va_step_voltage">Step Voltage (V):</label>
                <input type="number" id="va_step_voltage" name="va_step_voltage" value="0.1" step="0.01">
            </div>
            <div id="va_cc_settings" style="display: none;">
                <label for="va_start_current">Start Current (A):</label>
                <input type="number" id="va_start_current" name="va_start_current" value="0" step="0.01">
                <label for="va_end_current">End Current (A):</label>
                <input type="number" id="va_end_current" name="va_end_current" value="1" step="0.01">
                <label for="va_step_current">Step Current (A):</label>
                <input type="number" id="va_step_current" name="va_step_current" value="0.01" step="0.001">
            </div>
        </div>

        <!-- Bode Plot Settings -->
        <div id="settings_bode" class="settings-group">
            <h3>Bode Plot Settings</h3>
            <label for="bode_channel">Channel:</label>
            <select id="bode_channel" name="bode_channel">
                <option value="CH0">CH0</option>
                <option value="CH1">CH1</option>
                <option value="CH2">CH2</option>
            </select>
            <label for="bode_freq_from">Freq From (Hz):</label>
            <input type="number" id="bode_freq_from" name="bode_freq_from" value="10" min="1">
            <label for="bode_freq_to">Freq To (Hz):</label>
            <input type="number" id="bode_freq_to" name="bode_freq_to" value="10000" max="10000">
            <label for="bode_freq_steps">Freq Points/Decade:</label> <!-- Changed from step to points for better log scale -->
            <input type="number" id="bode_freq_steps" name="bode_freq_steps" value="10" min="1">
            <label for="bode_output_voltage">Output Voltage (V):</label>
            <input type="number" id="bode_output_voltage" name="bode_output_voltage" value="1" min="0" max="20" step="0.1">
        </div>

        <!-- Step Response Settings -->
        <div id="settings_step" class="settings-group">
            <h3>Step Response Settings</h3>
            <label for="step_channel">Channel:</label>
            <select id="step_channel" name="step_channel">
                <option value="CH0">CH0</option>
                <option value="CH1">CH1</option>
                <option value="CH2">CH2</option>
            </select>
            <label for="step_voltage">Voltage (V):</label>
            <input type="number" id="step_voltage" name="step_voltage" value="5" min="0" max="20" step="0.1">
            <label for="step_time">Measurement Time (s):</label>
            <input type="number" id="step_time" name="step_time" value="1" min="0.001" step="0.001">
        </div>

        <!-- Impulse Response Settings -->
        <div id="settings_impulse" class="settings-group">
            <h3>Impulse Response Settings</h3>
            <label for="impulse_voltage">Impulse Voltage (V):</label>
            <input type="number" id="impulse_voltage" name="impulse_voltage" value="5" min="0" max="20" step="0.1">
            <label for="impulse_duration">Impulse Duration (us):</label>
            <input type="number" id="impulse_duration" name="impulse_duration" value="10" min="1">
            <label for="impulse_time">Measurement Time (s):</label>
            <input type="number" id="impulse_time" name="impulse_time" value="0.1" min="0.001" step="0.001">
        </div>

        <!-- Testbed Settings -->
        <div id="settings_testbed" class="settings-group">
            <h3>Testbed Settings</h3>
            <label for="testbed_target_voltage">Target Output Voltage (V):</label>
            <input type="number" id="testbed_target_voltage" name="testbed_target_voltage" value="0" step="0.1" min="0" max="20">
            <label for="testbed_current_limit">Current Limit (A):</label>
            <input type="number" id="testbed_current_limit" name="testbed_current_limit" value="0.1" step="0.01" min="0" max="3">
            
            <h4>Live Readings:</h4>
            <div>Output Voltage: <span id="tb_out_v">-</span> V</div>
            <div>Output Current: <span id="tb_out_c">-</span> A</div>
            <div>Input CH0: <span id="tb_in_ch0">-</span> V</div>
            <div>Input CH1: <span id="tb_in_ch1">-</span> V</div>
        </div>

        <!-- Control Systems Toolbox Settings -->
        <div id="settings_control_system" class="settings-group">
            <h3>Control Systems Toolbox</h3>
            <label for="cs_mode">Mode:</label>
            <select id="cs_mode" name="cs_mode">
                <option value="controller">Device as Controller</option>
                <option value="system">Device as Controlled System</option>
            </select>

            <!-- Controller Specific Settings -->
            <div id="cs_controller_sub_settings">
                <label for="cs_controller_type">Controller Type:</label>
                <select id="cs_controller_type" name="cs_controller_type">
                    <option value="pid">PID Controller</option>
                    <option value="other">Other (from .ctl file)</option>
                </select>

                <div id="cs_pid_settings">
                    <h4>PID Parameters:</h4>
                    <label for="cs_pid_kp">Kp:</label>
                    <input type="number" id="cs_pid_kp" name="cs_pid_kp" value="1.0" step="0.01">
                    <label for="cs_pid_ki">Ki:</label>
                    <input type="number" id="cs_pid_ki" name="cs_pid_ki" value="0.1" step="0.01">
                    <label for="cs_pid_kd">Kd:</label>
                    <input type="number" id="cs_pid_kd" name="cs_pid_kd" value="0.01" step="0.001">
                </div>

                <!-- File Upload for Controller .ctl files -->
                <div id="cs_controller_file_upload_section" style="display: none;">
                    <h4>Controller File Upload:</h4>
                    <label for="cs_model_file_input">Upload Control Law File (.ctl):</label>
                    <input type="file" id="cs_model_file_input" name="cs_model_file_input" accept=".ctl">
                    <button type="button" id="cs_upload_button">Upload Model</button>
                </div>
            </div>

            <!-- System Specific Settings -->
            <div id="cs_system_sub_settings" style="display: none;">
                <h4>System Model Upload:</h4>
                <label for="cs_system_file_input">Upload System Model File (.mdl):</label>
                <input type="file" id="cs_system_file_input" name="cs_system_file_input" accept=".mdl">
                <button type="button" id="cs_system_upload_button">Upload Model</button>
            </div>

            <!-- Status Display -->
            <div id="cs_status_display">
                <div>Status: <span id="cs_status_text">No model uploaded</span></div>
                <div>Model Name: <span id="cs_model_name_text">-</span></div>
            </div>
        </div>


        <button id="measure_button">Measure</button>
        <button id="export_csv_button" disabled>Export CSV</button>
        <a href="{{ url_for('main.logout') }}" style="color: white; text-align: center; margin-top: 20px; display: block;">Logout</a>
    </div>
    <div class="main-content">
        <div id="graph" class="graph-container"></div>
    </div>

    <script>
        const measureButton = document.getElementById('measure_button');
        const exportCsvButton = document.getElementById('export_csv_button');
        const measureModeSelect = document.getElementById('measure_mode');
        const graphDiv = document.getElementById('graph');
        let currentChartData = null;
        let isContinuousRunning = false; // Track state for continuous modes
        let continuousDataInterval = null; // Interval for polling continuous data
        let continuousDataBuffer = {
            timestamps: [],
            inputs: [],
            states_x1: [],
            states_x2: [],
            outputs_y1: [],
            outputs_y2: []
        };

        const vaChannelSelect = document.getElementById('va_channel');
        const vaModeTypeSelect = document.getElementById('va_mode_type');
        const vaCvSettingsDiv = document.getElementById('va_cv_settings');
        const vaCcSettingsDiv = document.getElementById('va_cc_settings');

        const allSettingsGroups = document.querySelectorAll('.settings-group');

        // Control System specific elements
        const csModeSelect = document.getElementById('cs_mode');
        const csControllerSettingsDiv = document.getElementById('cs_controller_settings');
        const csSystemSettingsDiv = document.getElementById('cs_system_settings');

        // New Control System Elements
        const csControllerSubSettingsDiv = document.getElementById('cs_controller_sub_settings');
        const csSystemSubSettingsDiv = document.getElementById('cs_system_sub_settings');
        const csControllerTypeSelect = document.getElementById('cs_controller_type');
        const csPidSettingsDiv = document.getElementById('cs_pid_settings');
        const csFileUploadLabel = document.getElementById('cs_file_upload_label');
        const csModelFileInput = document.getElementById('cs_model_file_input');
        const csSystemFileInput = document.getElementById('cs_system_file_input');
        const csUploadButton = document.getElementById('cs_upload_button');
        const csSystemUploadButton = document.getElementById('cs_system_upload_button');
        const csFileUploadSection = document.getElementById('cs_file_upload_section');
        const csControllerFileUploadSection = document.getElementById('cs_controller_file_upload_section');
        const csStatusDisplay = document.getElementById('cs_status_display');
        const targetBoardSelect = document.getElementById('target_board');

        let uploadedModelData = null; // Store uploaded model data

        function updateMeasureButtonText() {
            const selectedMode = measureModeSelect.value;
            const csModeValue = csModeSelect ? csModeSelect.value : null;
            
            if (isContinuousRunning) {
                // Button shows "Stop" for all modes when running
                if (selectedMode === 'testbed') {
                    measureButton.textContent = 'Stop Testbed';
                } else if (selectedMode === 'control_system') {
                    if (csModeValue === 'controller') {
                        measureButton.textContent = 'Stop Controller';
                    } else {
                        measureButton.textContent = 'Stop System';
                    }
                } else if (selectedMode === 'va') {
                    measureButton.textContent = 'Stop VA';
                } else if (selectedMode === 'bode') {
                    measureButton.textContent = 'Stop Bode';
                } else if (selectedMode === 'step') {
                    measureButton.textContent = 'Stop Step';
                } else if (selectedMode === 'impulse') {
                    measureButton.textContent = 'Stop Impulse';
                } else {
                    measureButton.textContent = 'Stop';
                }
            } else {
                // Button shows "Start" for continuous modes, "Measure" for others
                if (selectedMode === 'testbed') {
                    measureButton.textContent = 'Start Testbed';
                } else if (selectedMode === 'control_system') {
                    if (csModeValue === 'controller') {
                        measureButton.textContent = 'Start Controller';
                    } else {
                        measureButton.textContent = 'Start System';
                    }
                } else if (['va', 'bode', 'step', 'impulse'].includes(selectedMode)) {
                    measureButton.textContent = 'Start ' + selectedMode.toUpperCase();
                } else {
                    measureButton.textContent = 'Measure';
                }
            }
        }

        function startContinuousDataPolling(boardId, mode) {
            console.log(`[DEBUG] Starting continuous data polling for board: ${boardId}, mode: ${mode}`);
            
            // Clear any existing interval
            if (continuousDataInterval) {
                clearInterval(continuousDataInterval);
            }

            // Clear data buffer for control system mode
            if (mode === 'control_system') {
                continuousDataBuffer = {
                    timestamps: [],
                    inputs: [],
                    states_x1: [],
                    states_x2: [],
                    outputs_y1: [],
                    outputs_y2: []
                };
            }

            // Poll for new data every 200ms for continuous modes, 1000ms for measurement modes
            const pollInterval = (mode === 'control_system' || mode === 'testbed') ? 200 : 1000;
            
            continuousDataInterval = setInterval(async () => {
                try {
                    const response = await fetch(`{{ url_for('main.get_continuous_data') }}?board_id=${boardId}&mode=${mode}`);
                    const data = await response.json();
                    
                    if (mode === 'control_system') {
                        // Handle control system data (array of data packets)
                        if (data && data.length > 0) {
                            data.forEach(dataPacket => {
                                if (dataPacket.type === 'data' && dataPacket.mode === 'control_system') {
                                    const payload = dataPacket.payload;
                                    console.log(`[DEBUG] Processing control system data packet with ${payload.sample_count} samples`);
                                    
                                    // Add new data to buffer
                                    continuousDataBuffer.timestamps.push(...payload.timestamps);
                                    continuousDataBuffer.inputs.push(...payload.inputs);
                                    continuousDataBuffer.states_x1.push(...payload.states_x1);
                                    continuousDataBuffer.states_x2.push(...payload.states_x2);
                                    continuousDataBuffer.outputs_y1.push(...payload.outputs_y1);
                                    continuousDataBuffer.outputs_y2.push(...payload.outputs_y2);
                                    
                                    // Keep only the last 1000 points for performance
                                    const maxPoints = 1000;
                                    if (continuousDataBuffer.timestamps.length > maxPoints) {
                                        const excess = continuousDataBuffer.timestamps.length - maxPoints;
                                        continuousDataBuffer.timestamps = continuousDataBuffer.timestamps.slice(excess);
                                        continuousDataBuffer.inputs = continuousDataBuffer.inputs.slice(excess);
                                        continuousDataBuffer.states_x1 = continuousDataBuffer.states_x1.slice(excess);
                                        continuousDataBuffer.states_x2 = continuousDataBuffer.states_x2.slice(excess);
                                        continuousDataBuffer.outputs_y1 = continuousDataBuffer.outputs_y1.slice(excess);
                                        continuousDataBuffer.outputs_y2 = continuousDataBuffer.outputs_y2.slice(excess);
                                    }
                                    
                                    // Update the graph
                                    updateContinuousGraph();
                                }
                            });
                        }
                    } else if (mode === 'testbed') {
                        // Handle testbed data (single object with readings)
                        if (data && data.mode === 'testbed' && data.readings) {
                            console.log(`[DEBUG] Processing testbed data`);
                            // Update testbed displays
                            document.getElementById('tb_out_v').textContent = data.readings.output_voltage !== undefined ? data.readings.output_voltage.toFixed(3) : '-';
                            document.getElementById('tb_out_c').textContent = data.readings.output_current !== undefined ? data.readings.output_current.toFixed(4) : '-';
                            document.getElementById('tb_in_ch0').textContent = data.readings.input_ch0 !== undefined ? data.readings.input_ch0.toFixed(3) : '-';
                            document.getElementById('tb_in_ch1').textContent = data.readings.input_ch1 !== undefined ? data.readings.input_ch1.toFixed(3) : '-';
                        }
                    } else if (mode === 'va') {
                        // Handle VA measurement data (accumulated data points)
                        if (data && data.mode === 'va' && data.data && data.data.length > 0) {
                            console.log(`[DEBUG] Processing VA data: ${data.data.length} points, ${data.progress}% complete`);
                            // Update the VA plot
                            const plot = {
                                x: data.data.map(p => p.voltage),
                                y: data.data.map(p => p.current),
                                type: 'scatter',
                                mode: 'lines+markers'
                            };
                            const layout = {
                                margin: { t: 30, b: 50, l: 60, r: 30 },
                                xaxis: { title: 'Voltage (V)' },
                                yaxis: { title: 'Current (A)' },
                                title: `VA Characteristics - ${data.progress.toFixed(1)}% Complete`
                            };
                            Plotly.newPlot(graphDiv, [plot], layout);
                            
                            // Stop polling if measurement is complete
                            if (data.completed) {
                                console.log('[DEBUG] VA measurement completed');
                                stopContinuousDataPolling();
                                isContinuousRunning = false;
                                updateMeasureButtonText();
                                layout.title = 'VA Characteristics - Complete';
                                Plotly.newPlot(graphDiv, [plot], layout);
                            }
                        }
                    } else if (['bode', 'step', 'impulse'].includes(mode)) {
                        // Handle other measurement modes similarly to VA
                        if (data && data.mode === mode && data.data && data.data.length > 0) {
                            console.log(`[DEBUG] Processing ${mode} data: ${data.data.length} points, ${data.progress}% complete`);
                            
                            let plot, layout;
                            if (mode === 'bode') {
                                const trace1 = {
                                    x: data.data.map(p => p.frequency),
                                    y: data.data.map(p => p.gain),
                                    name: 'Gain (dB)',
                                    type: 'scatter',
                                    mode: 'lines+markers'
                                };
                                const trace2 = {
                                    x: data.data.map(p => p.frequency),
                                    y: data.data.map(p => p.phase),
                                    name: 'Phase (°)',
                                    yaxis: 'y2',
                                    type: 'scatter',
                                    mode: 'lines+markers'
                                };
                                plot = [trace1, trace2];
                                layout = {
                                    margin: { t: 30, b: 50, l: 60, r: 30 },
                                    xaxis: { title: 'Frequency (Hz)', type: 'log' },
                                    yaxis: { title: 'Gain (dB)' },
                                    yaxis2: { title: 'Phase (°)', overlaying: 'y', side: 'right', showgrid: false },
                                    title: `Bode Plot - ${data.progress.toFixed(1)}% Complete`
                                };
                            } else {
                                plot = {
                                    x: data.data.map(p => p.time),
                                    y: data.data.map(p => p.response),
                                    type: 'scatter',
                                    mode: 'lines'
                                };
                                layout = {
                                    margin: { t: 30, b: 50, l: 60, r: 30 },
                                    xaxis: { title: 'Time (s)' },
                                    yaxis: { title: 'Response (V)' },
                                    title: `${mode.charAt(0).toUpperCase() + mode.slice(1)} Response - ${data.progress.toFixed(1)}% Complete`
                                };
                            }
                            
                            Plotly.newPlot(graphDiv, plot, layout);
                            
                            // Stop polling if measurement is complete
                            if (data.completed) {
                                console.log(`[DEBUG] ${mode} measurement completed`);
                                stopContinuousDataPolling();
                                isContinuousRunning = false;
                                updateMeasureButtonText();
                                layout.title = layout.title.replace(/- \d+.*% Complete/, '- Complete');
                                Plotly.newPlot(graphDiv, plot, layout);
                            }
                        }
                    }
                } catch (error) {
                    console.error(`[DEBUG] Error polling continuous data for ${mode}:`, error);
                }
            }, pollInterval);
        }

        function stopContinuousDataPolling() {
            console.log('[DEBUG] Stopping continuous data polling');
            if (continuousDataInterval) {
                clearInterval(continuousDataInterval);
                continuousDataInterval = null;
            }
        }

        function updateContinuousGraph() {
            if (continuousDataBuffer.timestamps.length === 0) return;

            // Convert timestamps to relative time in seconds
            const firstTimestamp = continuousDataBuffer.timestamps[0];
            const timeSeconds = continuousDataBuffer.timestamps.map(t => (t - firstTimestamp) / 1000.0);

            const traces = [
                {
                    x: timeSeconds,
                    y: continuousDataBuffer.inputs,
                    name: getInputName(1),
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'blue' }
                },
                {
                    x: timeSeconds,
                    y: continuousDataBuffer.states_x1,
                    name: 'State X1',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'red' }
                },
                {
                    x: timeSeconds,
                    y: continuousDataBuffer.states_x2,
                    name: 'State X2',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'green' }
                },
                {
                    x: timeSeconds,
                    y: continuousDataBuffer.outputs_y1,
                    name: getOutputName(1),
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'orange', dash: 'dot' }
                },
                {
                    x: timeSeconds,
                    y: continuousDataBuffer.outputs_y2,
                    name: getOutputName(2),
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'purple', dash: 'dot' }
                }
            ];

            const layout = {
                margin: { t: 30, b: 50, l: 60, r: 30 },
                xaxis: { title: 'Time (s)' },
                yaxis: { title: 'Value' },
                title: 'Control System - Real-time Data',
                showlegend: true,
                legend: { x: 0, y: 1 }
            };

            Plotly.newPlot(graphDiv, traces, layout);
        }

        function startMeasurementDataPolling(boardId, mode) {
            console.log(`[DEBUG] Starting measurement data polling for board: ${boardId}, mode: ${mode}`);
            
            // Clear any existing interval
            if (continuousDataInterval) {
                clearInterval(continuousDataInterval);
            }

            // Poll for measurement data every 500ms for non-continuous modes
            continuousDataInterval = setInterval(async () => {
                try {
                    const response = await fetch(`{{ url_for('main.get_measurement_data') }}?board_id=${boardId}&mode=${mode}`);
                    const data = await response.json();
                    
                    if (data && data.data && data.data.length > 0) {
                        console.log(`[DEBUG] Received ${mode} measurement data: ${data.data.length} points, ${data.progress}% complete`);
                        
                        // Plot the accumulated data
                        plotData([data], mode);
                        
                        // Check if measurement is complete
                        if (data.completed) {
                            console.log(`[DEBUG] ${mode} measurement completed`);
                            isContinuousRunning = false;
                            updateMeasureButtonText();
                            stopMeasurementDataPolling();
                        }
                    }
                } catch (error) {
                    console.error(`Error polling ${mode} data:`, error);
                }
            }, 500);
        }

        function stopMeasurementDataPolling() {
            console.log('[DEBUG] Stopping measurement data polling');
            if (continuousDataInterval) {
                clearInterval(continuousDataInterval);
                continuousDataInterval = null;
            }
        }

        async function fetchReadyBoards() {
            try {
                const response = await fetch("{{ url_for('main.get_boards') }}");
                const boards = await response.json();
                
                // Clear existing options
                targetBoardSelect.innerHTML = '';

                if (boards.length > 0) {
                    boards.forEach(board => {
                        const option = document.createElement('option');
                        option.value = board;
                        option.textContent = board;
                        targetBoardSelect.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = "";
                    option.textContent = "No ready boards found";
                    option.disabled = true;
                    targetBoardSelect.appendChild(option);
                }
            } catch (error) {
                console.error("Error fetching boards:", error);
            }
        }

        function updateSettingsVisibility() {
            const selectedMode = measureModeSelect.value;
            
            // Stop continuous polling when mode changes
            if (isContinuousRunning && continuousDataInterval) {
                stopContinuousDataPolling();
                isContinuousRunning = false;
            }
            
            allSettingsGroups.forEach(group => {
                group.classList.remove('active');
            });
            const activeSettingsGroup = document.getElementById('settings_' + selectedMode);
            if (activeSettingsGroup) {
                activeSettingsGroup.classList.add('active');
            }

            // VA specific logic for CC/CV
            if (selectedMode === 'va') {
                const selectedChannel = vaChannelSelect.value;
                if (selectedChannel === 'CH2') {
                    vaModeTypeSelect.disabled = false;
                    if (vaModeTypeSelect.value === 'CV') {
                        vaCvSettingsDiv.style.display = 'block';
                        vaCcSettingsDiv.style.display = 'none';
                    } else { // CC
                        vaCvSettingsDiv.style.display = 'none';
                        vaCcSettingsDiv.style.display = 'block';
                    }
                } else { // CH0 or CH1
                    vaModeTypeSelect.value = 'CV'; // Force CV
                    vaModeTypeSelect.disabled = true;
                    vaCvSettingsDiv.style.display = 'block';
                    vaCcSettingsDiv.style.display = 'none';
                }
            }
            // Control System specific logic for sub-settings
            if (selectedMode === 'control_system' && csModeSelect) {
                if (csModeSelect.value === 'controller') {
                    csControllerSubSettingsDiv.style.display = 'block';
                    csSystemSubSettingsDiv.style.display = 'none';
                    csStatusDisplay.style.display = 'block';
                    
                    // Show/hide based on controller type
                    if (csControllerTypeSelect.value === 'pid') {
                        csPidSettingsDiv.style.display = 'block';
                        csControllerFileUploadSection.style.display = 'none';
                        // Reset status for PID mode
                        document.getElementById('cs_status_text').textContent = 'Using PID parameters';
                        document.getElementById('cs_model_name_text').textContent = 'PID Controller';
                    } else {
                        csPidSettingsDiv.style.display = 'none';
                        csControllerFileUploadSection.style.display = 'block';
                        // Reset status for file mode
                        document.getElementById('cs_status_text').textContent = 'No model uploaded';
                        document.getElementById('cs_model_name_text').textContent = '-';
                    }
                } else { // system
                    csControllerSubSettingsDiv.style.display = 'none';
                    csSystemSubSettingsDiv.style.display = 'block';
                    csPidSettingsDiv.style.display = 'none';
                    csStatusDisplay.style.display = 'block';
                    // Reset status for system mode
                    document.getElementById('cs_status_text').textContent = 'No model uploaded';
                    document.getElementById('cs_model_name_text').textContent = '-';
                }
            }
            
            // Update measure button text based on selected mode
            updateMeasureButtonText();
        }
        
        measureModeSelect.addEventListener('change', updateSettingsVisibility);
        if(vaChannelSelect) vaChannelSelect.addEventListener('change', updateSettingsVisibility);
        if(vaModeTypeSelect) vaModeTypeSelect.addEventListener('change', updateSettingsVisibility);
        if(csModeSelect) csModeSelect.addEventListener('change', updateSettingsVisibility); // Listener for CS mode change
        if(csControllerTypeSelect) csControllerTypeSelect.addEventListener('change', updateSettingsVisibility); // Listener for CS controller type change

        // Upload button functionality for controller files
        if(csUploadButton) {
            csUploadButton.addEventListener('click', async () => {
                const fileInput = document.getElementById('cs_model_file_input');
                if (!fileInput.files || fileInput.files.length === 0) {
                    document.getElementById('cs_status_text').textContent = 'No file selected';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    return;
                }

                const file = fileInput.files[0];
                console.log(`[DEBUG] Uploading controller file: ${file.name}, size: ${file.size}, type: ${file.type}`);

                if (!file.name.endsWith('.ctl')) {
                    document.getElementById('cs_status_text').textContent = 'Wrong file type. Expected .ctl';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    return;
                }

                try {
                    const text = await file.text();
                    const modelData = JSON.parse(text);
                    
                    console.log(`[DEBUG] Controller file parsed successfully:`, modelData);
                    
                    uploadedModelData = modelData;
                    document.getElementById('cs_status_text').textContent = 'Controller uploaded successfully';
                    document.getElementById('cs_model_name_text').textContent = modelData.controller_name || file.name;
                    
                } catch (error) {
                    console.error(`[DEBUG] Controller file parsing error:`, error);
                    document.getElementById('cs_status_text').textContent = 'Invalid file format';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    uploadedModelData = null;
                }
            });
        }

        // Upload button functionality for system files
        if(csSystemUploadButton) {
            csSystemUploadButton.addEventListener('click', async () => {
                const fileInput = document.getElementById('cs_system_file_input');
                if (!fileInput.files || fileInput.files.length === 0) {
                    document.getElementById('cs_status_text').textContent = 'No file selected';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    return;
                }

                const file = fileInput.files[0];
                console.log(`[DEBUG] Uploading system file: ${file.name}, size: ${file.size}, type: ${file.type}`);

                if (!file.name.endsWith('.mdl')) {
                    document.getElementById('cs_status_text').textContent = 'Wrong file type. Expected .mdl';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    return;
                }

                try {
                    const text = await file.text();
                    const modelData = JSON.parse(text);
                    
                    console.log(`[DEBUG] System file parsed successfully:`, modelData);
                    
                    uploadedModelData = modelData;
                    document.getElementById('cs_status_text').textContent = 'Model uploaded successfully';
                    document.getElementById('cs_model_name_text').textContent = modelData.system_name || file.name;
                    
                } catch (error) {
                    console.error(`[DEBUG] System file parsing error:`, error);
                    document.getElementById('cs_status_text').textContent = 'Invalid file format';
                    document.getElementById('cs_model_name_text').textContent = '-';
                    uploadedModelData = null;
                }
            });
        }

        function getOutputName(outputIndex) {
            // Get output name from uploaded model data, fallback to default names
            if (uploadedModelData && uploadedModelData.output_mapping && uploadedModelData.output_mapping.length >= outputIndex) {
                const outputMapping = uploadedModelData.output_mapping[outputIndex - 1];
                return outputMapping?.output_name || `Output Y${outputIndex}`;
            }
            return `Output Y${outputIndex}`;
        }

        function getInputName(inputIndex) {
            // Get input name from uploaded model data, fallback to default names
            if (uploadedModelData && uploadedModelData.input_mapping && uploadedModelData.input_mapping.length >= inputIndex) {
                const inputMapping = uploadedModelData.input_mapping[inputIndex - 1];
                return inputMapping?.input_name || `Input ${inputIndex}`;
            }
            return `Input ${inputIndex}`;
        }

        measureButton.addEventListener('click', async () => {
            const mode = measureModeSelect.value;
            const targetBoard = document.getElementById('target_board').value;
            
            // Check if this is a continuous mode and if it's currently running
            const isContinuousMode = (mode === 'testbed' || mode === 'control_system');
            
            if (isContinuousMode && isContinuousRunning) {
                // Stop the continuous mode
                try {
                    const stopFormData = new FormData();
                    stopFormData.append('measure_mode', mode);
                    stopFormData.append('target_board', targetBoard);
                    
                    const response = await fetch("{{ url_for('main.stop') }}", {
                        method: 'POST',
                        body: stopFormData
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok) {
                        isContinuousRunning = false;
                        updateMeasureButtonText();
                        
                        // Clear any continuous data displays
                        if (mode === 'testbed') {
                            document.getElementById('tb_out_v').textContent = '-';
                            document.getElementById('tb_out_c').textContent = '-';
                            document.getElementById('tb_in_ch0').textContent = '-';
                            document.getElementById('tb_in_ch1').textContent = '-';
                        } else if (mode === 'control_system') {
                            // Stop continuous data polling
                            stopContinuousDataPolling();
                            
                            // Update status to show stopped
                            const currentStatus = document.getElementById('cs_status_text').textContent;
                            if (!currentStatus.includes('uploaded')) {
                                document.getElementById('cs_status_text').textContent = 'Stopped';
                            }
                        }
                        
                        // Clear the graph
                        Plotly.newPlot(graphDiv, [], {
                            margin: { t: 30, b: 50, l: 60, r: 30 },
                            title: `${mode.toUpperCase()} - Stopped`
                        });
                        
                        console.log('Stopped:', data.message);
                    } else {
                        alert('Error stopping: ' + (data.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Stop error:', error);
                    alert('Failed to stop the measurement.');
                }
                return;
            }
            
            // Start measurement (original logic)
            const formData = new FormData();
            formData.append('measure_mode', mode);
            formData.append('target_board', targetBoard);

            // Collect data from the active settings group
            const activeSettingsGroup = document.querySelector('.settings-group.active');
            if (activeSettingsGroup) {
                const inputs = activeSettingsGroup.querySelectorAll('input[type="number"], input[type="text"], select'); // query for specific input types
                inputs.forEach(input => {
                    if (!input.disabled && input.name) { // only include enabled inputs with a name
                         formData.append(input.name, input.value);
                    }
                });
                // Handle file input - don't send file, send pre-uploaded model data
                const fileInput = activeSettingsGroup.querySelector('input[type="file"]');
                if (fileInput) {
                    // For control system mode with system, check if model data is available
                    if (mode === 'control_system' && formData.get('cs_mode') === 'system') {
                        if (uploadedModelData) {
                            // Send the model data directly as JSON string
                            formData.append('cs_model_data', JSON.stringify(uploadedModelData));
                            const systemFileInput = document.getElementById('cs_system_file_input');
                            formData.append('cs_model_file_input_name', systemFileInput.files[0]?.name || 'uploaded_model.mdl');
                        } else {
                            alert('Please upload a model file first using the Upload Model button.');
                            return;
                        }
                    } else if (mode === 'control_system' && formData.get('cs_mode') === 'controller' && formData.get('cs_controller_type') === 'other') {
                        if (uploadedModelData) {
                            // Send the controller data directly as JSON string
                            formData.append('cs_model_data', JSON.stringify(uploadedModelData));
                            const controllerFileInput = document.getElementById('cs_model_file_input');
                            formData.append('cs_model_file_input_name', controllerFileInput.files[0]?.name || 'uploaded_controller.ctl');
                        } else {
                            alert('Please upload a controller file first using the Upload Model button.');
                            return;
                        }
                    } else if (fileInput.files && fileInput.files.length > 0) {
                        formData.append(fileInput.name, fileInput.files[0]); // Send actual file for other modes
                        formData.append(fileInput.name + '_name', fileInput.files[0].name);
                    } else {
                        formData.append(fileInput.name + '_name', ''); // Send empty if no file selected
                    }
                }

                 // Special handling for VA CH0/CH1 to ensure va_mode_type is CV
                if (mode === 'va') {
                    const channel = document.getElementById('va_channel').value;
                    if (channel === 'CH0' || channel === 'CH1') {
                        formData.set('va_mode_type', 'CV'); // Ensure CV is sent
                    }
                }
            }

            // Clear the graph before starting new measurement
            Plotly.newPlot(graphDiv, [], {
                margin: { t: 30, b: 50, l: 60, r: 30 },
                title: `${mode.toUpperCase()} - Starting...`
            });

            try {
                const response = await fetch("{{ url_for('main.measure') }}", {
                    method: 'POST',
                    body: formData  // FormData automatically sets correct Content-Type with boundary
                });
                const data = await response.json();
                
                if (response.ok) {
                    currentChartData = data; // Store data for export
                    plotData(data, mode);
                    exportCsvButton.disabled = !data || (Array.isArray(data) && data.length === 0) || (typeof data === 'object' && Object.keys(data).length === 0);
                    
                    // Update state for continuous modes
                    if (isContinuousMode) {
                        isContinuousRunning = true;
                        updateMeasureButtonText();
                        
                        // Start continuous data polling for control system mode
                        if (mode === 'control_system') {
                            startContinuousDataPolling(targetBoard, mode);
                        }
                    } else if (mode === 'testbed') {
                        // Testbed is continuous
                        isContinuousRunning = true;
                        updateMeasureButtonText();
                        startContinuousDataPolling(targetBoard, mode);
                    } else if (['va', 'bode', 'step', 'impulse'].includes(mode)) {
                        // These modes are non-continuous measurements with progress tracking
                        isContinuousRunning = true;
                        updateMeasureButtonText();
                        startMeasurementDataPolling(targetBoard, mode);
                    }
                } else {
                    alert('Error starting measurement: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Measure error:', error);
                alert('Failed to start measurement.');
            }
        });

        exportCsvButton.addEventListener('click', async () => {
            if (!currentChartData || currentChartData.length === 0) {
                alert("No data to export.");
                return;
            }
            try {
                const response = await fetch("{{ url_for('main.export_csv') }}", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ data: currentChartData })
                });

                if (response.ok) {
                    const blob = await response.blob();
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = 'measurement_data.csv';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } else {
                    const error = await response.json();
                    alert("Error exporting CSV: " + (error.error || "Unknown error"));
                }
            } catch (error) {
                console.error("Export error:", error);
                alert("Failed to export CSV.");
            }
        });

        function plotData(data, mode) {
            let plot = {};
            let layout = {
                margin: { t: 30, b: 50, l: 60, r: 30 },
                xaxis: {},
                yaxis: {},
                yaxis2: {
                    overlaying: 'y',
                    side: 'right',
                    showgrid: false,
                },
                title: mode.toUpperCase() + ' Measurement' // Generic title
            };
            
            // Clear previous plot and specific displays
            Plotly.newPlot(graphDiv, [], layout); // Clear graph
            document.getElementById('tb_out_v').textContent = '-';
            document.getElementById('tb_out_c').textContent = '-';
            document.getElementById('tb_in_ch0').textContent = '-';
            document.getElementById('tb_in_ch1').textContent = '-';
            // Note: Don't clear cs_status_text and cs_model_name_text here as they show upload status

            if (!data || ((Array.isArray(data) && data.length === 0)) || (typeof data === 'object' && !data.type && Object.keys(data).length === 0) ) { // Adjusted condition for CS data
                return;
            }
            
            if (mode === 'va') {
                if (data.type === "va_started") {
                    // Handle VA measurement start
                    layout.title = 'VA Characteristics - Collecting Data...';
                    layout.xaxis.title = 'Voltage (V)';
                    layout.yaxis.title = 'Current (A)';
                    Plotly.newPlot(graphDiv, [], layout);
                    console.log('[DEBUG] VA measurement started, data collection will begin');
                } else if (Array.isArray(data) && data.length > 0) {
                    // Handle accumulated VA data
                    plot = {
                        x: data.map(p => p.voltage),
                        y: data.map(p => p.current),
                        type: 'scatter',
                        mode: 'lines+markers'
                    };
                    layout.xaxis.title = 'Voltage (V)';
                    layout.yaxis.title = 'Current (A)';
                    layout.title = 'VA Characteristics';
                    Plotly.newPlot(graphDiv, [plot], layout);
                } else {
                    // Default empty plot
                    layout.xaxis.title = 'Voltage (V)';
                    layout.yaxis.title = 'Current (A)';
                    layout.title = 'VA Characteristics';
                    Plotly.newPlot(graphDiv, [], layout);
                }
            } else if (mode === 'bode') {
                const trace1 = {
                    x: data.map(p => p.frequency),
                    y: data.map(p => p.gain),
                    name: 'Gain (dB)',
                    type: 'scatter',
                    mode: 'lines+markers'
                };
                const trace2 = {
                    x: data.map(p => p.frequency),
                    y: data.map(p => p.phase),
                    name: 'Phase (°)',
                    yaxis: 'y2',
                    type: 'scatter',
                    mode: 'lines+markers'
                };
                plot = [trace1, trace2];
                layout.xaxis.title = 'Frequency (Hz)';
                layout.xaxis.type = 'log';
                layout.yaxis.title = 'Gain (dB)';
                layout.yaxis2.title = 'Phase (°)';
                layout.title = 'Bode Plot';
                Plotly.newPlot(graphDiv, plot, layout);
            } else if (mode === 'step' || mode === 'impulse') {
                plot = {
                    x: data.map(p => p.time),
                    y: data.map(p => p.response),
                    type: 'scatter',
                    mode: 'lines'
                };
                layout.xaxis.title = 'Time (s)';
                layout.yaxis.title = 'Response (V)';
                layout.title = mode === 'step' ? 'Step Response' : 'Impulse Response';
                Plotly.newPlot(graphDiv, [plot], layout);
            } else if (mode === 'testbed') {
                // For testbed, we update spans, not a graph primarily
                document.getElementById('tb_out_v').textContent = data.output_voltage !== undefined ? data.output_voltage.toFixed(3) : '-';
                document.getElementById('tb_out_c').textContent = data.output_current !== undefined ? data.output_current.toFixed(4) : '-';
                document.getElementById('tb_in_ch0').textContent = data.input_ch0 !== undefined ? data.input_ch0.toFixed(3) : '-';
                document.getElementById('tb_in_ch1').textContent = data.input_ch1 !== undefined ? data.input_ch1.toFixed(3) : '-';
                layout.title = 'Testbed - Live Readings';
                // Optionally, could plot one of these values over time if desired, but for now, just text.
                Plotly.newPlot(graphDiv, [], layout); // Keep graph area clean or show a relevant message
            } else if (mode === 'control_system') {
                if (data.type === "pid_response" && data.data) {
                    plot = {
                        x: data.data.map(p => p.time),
                        y: data.data.map(p => p.response),
                        type: 'scatter',
                        mode: 'lines'
                    };
                    layout.xaxis.title = 'Time (s)';
                    layout.yaxis.title = 'System Response';
                    let params_str = "PID Params: " + Object.entries(data.params || {}).map(([k,v]) => `${k}=${v}`).join(', ');
                    // Update status but don't overwrite upload status
                    if (document.getElementById('cs_status_text').textContent.includes('uploaded')) {
                        document.getElementById('cs_status_text').textContent += ` | ${data.status || ""}`;
                    } else {
                        document.getElementById('cs_status_text').textContent = data.status || "";
                    }
                    layout.title = 'PID Controller Response';
                    Plotly.newPlot(graphDiv, [plot], layout);
                } else if (data.type === "control_system_started") {
                    // Handle the new control system started response
                    const statusText = data.message || "Control system started";
                    
                    // Update status but don't overwrite upload status
                    if (document.getElementById('cs_status_text').textContent.includes('uploaded')) {
                        document.getElementById('cs_status_text').textContent += ` | Running`;
                    } else {
                        document.getElementById('cs_status_text').textContent = statusText;
                    }
                    
                    // Set up initial empty graph for real-time data
                    layout.title = 'Control System - Real-time Data (Waiting for data...)';
                    layout.xaxis.title = 'Time (s)';
                    layout.yaxis.title = 'Value';
                    Plotly.newPlot(graphDiv, [], layout);
                    
                    console.log('[DEBUG] Control system started, real-time graphing will begin when data arrives');
                } else {
                    // Update status but don't overwrite upload status  
                    if (document.getElementById('cs_status_text').textContent.includes('uploaded')) {
                        document.getElementById('cs_status_text').textContent += ` | ${data.status || ""}`;
                    } else {
                        document.getElementById('cs_status_text').textContent = data.status || "";
                    }
                    layout.title = 'Control Systems Toolbox - Status';
                    Plotly.newPlot(graphDiv, [], layout); // Clear graph or show general status
                }
            }
        }
        // Initial setup
        updateSettingsVisibility();
        fetchReadyBoards(); // Fetch boards on page load
        setInterval(fetchReadyBoards, 5000); // Refresh board list every 5 seconds
    </script>
</body>
</html>
